diff -u --recursive --new-file v2.1.129/linux/fs/Config.in linux/fs/Config.in
--- v2.1.129/linux/fs/Config.in	Sun Nov 29 19:13:55 1998
+++ linux/fs/Config.in	Sun Nov 29 14:45:28 1998
@@ -82,6 +82,7 @@
   if [ "$CONFIG_QNX4FS_FS" != "n" ]; then
     bool '   QNXFS read-write support (FOR TESTING ONLY)' CONFIG_QNX4FS_RW
   fi    
+  tristate 'UDF filesystem support (read only) (EXPERIMENTAL)' CONFIG_UDF_FS
 fi
 bool 'Macintosh partition map support' CONFIG_MAC_PARTITION
 endmenu
diff -u --recursive --new-file v2.1.129/linux/fs/Makefile linux/fs/Makefile
--- v2.1.129/linux/fs/Makefile	Mon Aug 31 16:01:35 1998
+++ linux/fs/Makefile	Sun Nov 29 16:35:15 1998
@@ -18,7 +18,7 @@
 MOD_LIST_NAME := FS_MODULES
 ALL_SUB_DIRS = coda minix ext2 fat msdos vfat proc isofs nfs umsdos ntfs \
 		hpfs sysv smbfs ncpfs ufs affs romfs autofs hfs lockd nfsd \
-		nls devpts adfs qnx4
+		nls devpts adfs qnx4 udf
 
 ifeq ($(CONFIG_QUOTA),y)
 O_OBJS += dquot.o
@@ -212,6 +212,14 @@
 else
   ifeq ($(CONFIG_QNX4FS_FS),m)
   MOD_SUB_DIRS += qnx4
+  endif
+endif
+
+ifeq ($(CONFIG_UDF_FS),y)
+SUB_DIRS += udf
+else
+  ifeq ($(CONFIG_UDF_FS),m)
+  MOD_SUB_DIRS += udf
   endif
 endif
 
diff -u --recursive --new-file v2.1.129/linux/fs/filesystems.c linux/fs/filesystems.c
--- v2.1.129/linux/fs/filesystems.c	Sun Sep  6 15:55:38 1998
+++ linux/fs/filesystems.c	Sun Nov 29 14:45:28 1998
@@ -25,6 +25,7 @@
 #include <linux/romfs_fs.h>
 #include <linux/auto_fs.h>
 #include <linux/qnx4_fs.h>
+#include <linux/udf_fs.h>
 #include <linux/ntfs_fs.h>
 #include <linux/hfs_fs.h>
 #include <linux/devpts_fs.h>
@@ -145,6 +146,10 @@
 	init_qnx4_fs();
 #endif
    
+#ifdef CONFIG_UDF_FS
+	init_udf_fs();
+#endif
+
 #ifdef CONFIG_NLS
 	init_nls();
 #endif
diff -u --recursive --new-file v2.1.129/linux/include/linux/fs.h linux/include/linux/fs.h
--- v2.1.129/linux/include/linux/fs.h	Sun Nov 29 19:13:42 1998
+++ linux/include/linux/fs.h	Sun Nov 29 16:54:24 1998
@@ -281,6 +281,7 @@
 #include <linux/hfs_fs_i.h>
 #include <linux/adfs_fs_i.h>
 #include <linux/qnx4_fs_i.h>
+#include <linux/udf_fs_i.h>
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what
@@ -392,6 +393,7 @@
 		struct hfs_inode_info		hfs_i;
 		struct adfs_inode_info		adfs_i;
 		struct qnx4_inode_info		qnx4_i;	   
+		struct udf_inode_info		udf_i;
 		struct socket			socket_i;
 		void				*generic_ip;
 	} u;
@@ -513,6 +515,7 @@
 #include <linux/hfs_fs_sb.h>
 #include <linux/adfs_fs_sb.h>
 #include <linux/qnx4_fs_sb.h>
+#include <linux/udf_fs_sb.h>
 
 extern struct list_head super_blocks;
 
@@ -555,6 +558,7 @@
 		struct hfs_sb_info	hfs_sb;
 		struct adfs_sb_info	adfs_sb;
 		struct qnx4_sb_info	qnx4_sb;	   
+		struct udf_sb_info	udf_sb;
 		void			*generic_sbp;
 	} u;
 };
diff -u --recursive --new-file v2.1.129/linux/Documentation/Configure.help linux/Documentation/Configure.help
--- v2.1.129/linux/Documentation/Configure.help	Sun Nov 29 19:13:47 1998
+++ linux/Documentation/Configure.help	Sun Nov 29 16:58:13 1998
@@ -6838,6 +6838,18 @@
 
   If unsure, say N.
 
+UDF filesystem support (EXPERIMENTAL)
+CONFIG_UDF_FS  
+  This is the new filesystem used by some CDROMS and DVD drivers. 
+  Say Y if you intend to mount DVD discs or CDRWs written in packet mode.
+
+  This filesystem support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module is called udf.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. 
+
+  If unsure, say N.
+
 Kernel automounter support
 CONFIG_AUTOFS_FS
   The automounter is a tool to automatically mount remote filesystems
diff -u --recursive --new-file v2.1.129/linux/fs/udf/Makefile linux/fs/udf/Makefile
--- v2.1.129/linux/fs/udf/Makefile	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/Makefile	Sun Nov 29 17:17:05 1998
@@ -0,0 +1,15 @@
+#
+# Makefile for the linux udf-filesystem routines.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile...
+
+O_TARGET := udf.o
+O_OBJS   := crc.o debug.o inode.o dir.o directory.o file.o misc.o super.o \
+udftime.o unicode.o
+M_OBJS   := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -u --recursive --new-file v2.1.129/linux/fs/udf/crc.c linux/fs/udf/crc.c
--- v2.1.129/linux/fs/udf/crc.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/crc.c	Sun Nov 29 14:45:28 1998
@@ -0,0 +1,179 @@
+/*
+ * crc.c
+ *
+ * PURPOSE
+ *	Routines to generate, calculate, and test a 16-bit CRC.
+ *
+ * DESCRIPTION
+ *	The CRC code was devised by Don P. Mitchell of AT&T Bell Laboratories
+ *	and Ned W. Rhodes of Software Systems Group. It has been published in
+ *	"Design and Validation of Computer Protocols", Prentice Hall,
+ *	Englewood Cliffs, NJ, 1991, Chapter 3, ISBN 0-13-539925-4.
+ *
+ *	Copyright is held by AT&T.
+ *
+ *	AT&T gives permission for the free use of the CRC source code.
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ */
+
+#include <linux/udf_fs.h>
+
+static Uint16 crc_table[256] = {
+	0x0000U, 0x1021U, 0x2042U, 0x3063U, 0x4084U, 0x50a5U, 0x60c6U, 0x70e7U,
+	0x8108U, 0x9129U, 0xa14aU, 0xb16bU, 0xc18cU, 0xd1adU, 0xe1ceU, 0xf1efU,
+	0x1231U, 0x0210U, 0x3273U, 0x2252U, 0x52b5U, 0x4294U, 0x72f7U, 0x62d6U,
+	0x9339U, 0x8318U, 0xb37bU, 0xa35aU, 0xd3bdU, 0xc39cU, 0xf3ffU, 0xe3deU,
+	0x2462U, 0x3443U, 0x0420U, 0x1401U, 0x64e6U, 0x74c7U, 0x44a4U, 0x5485U,
+	0xa56aU, 0xb54bU, 0x8528U, 0x9509U, 0xe5eeU, 0xf5cfU, 0xc5acU, 0xd58dU,
+	0x3653U, 0x2672U, 0x1611U, 0x0630U, 0x76d7U, 0x66f6U, 0x5695U, 0x46b4U,
+	0xb75bU, 0xa77aU, 0x9719U, 0x8738U, 0xf7dfU, 0xe7feU, 0xd79dU, 0xc7bcU,
+	0x48c4U, 0x58e5U, 0x6886U, 0x78a7U, 0x0840U, 0x1861U, 0x2802U, 0x3823U,
+	0xc9ccU, 0xd9edU, 0xe98eU, 0xf9afU, 0x8948U, 0x9969U, 0xa90aU, 0xb92bU,
+	0x5af5U, 0x4ad4U, 0x7ab7U, 0x6a96U, 0x1a71U, 0x0a50U, 0x3a33U, 0x2a12U,
+	0xdbfdU, 0xcbdcU, 0xfbbfU, 0xeb9eU, 0x9b79U, 0x8b58U, 0xbb3bU, 0xab1aU,
+	0x6ca6U, 0x7c87U, 0x4ce4U, 0x5cc5U, 0x2c22U, 0x3c03U, 0x0c60U, 0x1c41U,
+	0xedaeU, 0xfd8fU, 0xcdecU, 0xddcdU, 0xad2aU, 0xbd0bU, 0x8d68U, 0x9d49U,
+	0x7e97U, 0x6eb6U, 0x5ed5U, 0x4ef4U, 0x3e13U, 0x2e32U, 0x1e51U, 0x0e70U,
+	0xff9fU, 0xefbeU, 0xdfddU, 0xcffcU, 0xbf1bU, 0xaf3aU, 0x9f59U, 0x8f78U,
+	0x9188U, 0x81a9U, 0xb1caU, 0xa1ebU, 0xd10cU, 0xc12dU, 0xf14eU, 0xe16fU,
+	0x1080U, 0x00a1U, 0x30c2U, 0x20e3U, 0x5004U, 0x4025U, 0x7046U, 0x6067U,
+	0x83b9U, 0x9398U, 0xa3fbU, 0xb3daU, 0xc33dU, 0xd31cU, 0xe37fU, 0xf35eU,
+	0x02b1U, 0x1290U, 0x22f3U, 0x32d2U, 0x4235U, 0x5214U, 0x6277U, 0x7256U,
+	0xb5eaU, 0xa5cbU, 0x95a8U, 0x8589U, 0xf56eU, 0xe54fU, 0xd52cU, 0xc50dU,
+	0x34e2U, 0x24c3U, 0x14a0U, 0x0481U, 0x7466U, 0x6447U, 0x5424U, 0x4405U,
+	0xa7dbU, 0xb7faU, 0x8799U, 0x97b8U, 0xe75fU, 0xf77eU, 0xc71dU, 0xd73cU,
+	0x26d3U, 0x36f2U, 0x0691U, 0x16b0U, 0x6657U, 0x7676U, 0x4615U, 0x5634U,
+	0xd94cU, 0xc96dU, 0xf90eU, 0xe92fU, 0x99c8U, 0x89e9U, 0xb98aU, 0xa9abU,
+	0x5844U, 0x4865U, 0x7806U, 0x6827U, 0x18c0U, 0x08e1U, 0x3882U, 0x28a3U,
+	0xcb7dU, 0xdb5cU, 0xeb3fU, 0xfb1eU, 0x8bf9U, 0x9bd8U, 0xabbbU, 0xbb9aU,
+	0x4a75U, 0x5a54U, 0x6a37U, 0x7a16U, 0x0af1U, 0x1ad0U, 0x2ab3U, 0x3a92U,
+	0xfd2eU, 0xed0fU, 0xdd6cU, 0xcd4dU, 0xbdaaU, 0xad8bU, 0x9de8U, 0x8dc9U,
+	0x7c26U, 0x6c07U, 0x5c64U, 0x4c45U, 0x3ca2U, 0x2c83U, 0x1ce0U, 0x0cc1U,
+	0xef1fU, 0xff3eU, 0xcf5dU, 0xdf7cU, 0xaf9bU, 0xbfbaU, 0x8fd9U, 0x9ff8U,
+	0x6e17U, 0x7e36U, 0x4e55U, 0x5e74U, 0x2e93U, 0x3eb2U, 0x0ed1U, 0x1ef0U
+};
+
+/*
+ * udf_crc
+ *
+ * PURPOSE
+ *	Calculate a 16-bit CRC checksum using ITU-T V.41 polynomial.
+ *
+ * DESCRIPTION
+ *	The OSTA-UDF(tm) 1.50 standard states that using CRCs is mandatory.
+ *	The polynomial used is:	x^16 + x^12 + x^15 + 1
+ *
+ * PRE-CONDITIONS
+ *	data		Pointer to the data block.
+ *	size		Size of the data block.
+ *
+ * POST-CONDITIONS
+ *	<return>	CRC of the data block.
+ *
+ * HISTORY
+ *	July 21, 1997 - Andrew E. Mileski
+ *	Adapted from OSTA-UDF(tm) 1.50 standard.
+ */
+extern Uint16
+udf_crc(Uint8 *data, Uint32 size)
+{
+	register Uint16 crc = 0;
+
+	while (size--)
+		crc = crc_table[(crc >> 8 ^ *(data++)) & 0xffU] ^ (crc << 8);
+
+	return crc;
+}
+
+/****************************************************************************/
+#if defined(TEST)
+
+/*
+ * PURPOSE
+ *	Test udf_crc()
+ *
+ * HISTORY
+ *	July 21, 1997 - Andrew E. Mileski
+ *	Adapted from OSTA-UDF(tm) 1.50 standard.
+ */
+
+unsigned char bytes[] = { 0x70U, 0x6AU, 0x77U };
+
+int main(void)
+{
+	unsigned short x;
+
+	x = udf_crc16(bytes, sizeof bytes);
+	printf("udf_crc16: calculated = %4.4x, correct = %4.4x\n", x, 0x3299U);
+
+	return 0;
+}
+
+#endif /* defined(TEST) */
+/****************************************************************************/
+#if defined(GENERATE)
+
+/*
+ * PURPOSE
+ *	Generate a table for fast 16-bit CRC calculations (any polynomial).
+ *
+ * DESCRIPTION
+ *	The ITU-T V.41 polynomial is 010041.
+ *
+ * HISTORY
+ *	July 21, 1997 - Andrew E. Mileski
+ *	Adapted from OSTA-UDF(tm) 1.50 standard.
+ */
+
+#include <stdio.h>
+
+int main(int argc, char **argv)
+{
+	unsigned long crc, poly;
+	int n, i;
+
+	/* Get the polynomial */
+	sscanf(argv[1], "%lo", &poly);
+	if (poly & 0xffff0000U){
+		fprintf(stderr, "polynomial is too large\en");
+		exit(1);
+	}
+
+	printf("/* CRC 0%o */\n", poly);
+
+	/* Create a table */
+	printf("static unsigned short crc_table[256] = {\n");
+	for (n = 0; n < 256; n++){
+		if (n % 8 == 0)
+			printf("\t");
+		crc = n << 8;
+		for (i = 0; i < 8; i++){
+			if(crc & 0x8000U)
+				crc = (crc << 1) ^ poly;
+			else
+				crc <<= 1;
+		crc &= 0xFFFFU;
+		}
+		if (n == 255)
+			printf("0x%04xU ", crc);
+		else
+			printf("0x%04xU, ", crc);
+		if(n % 8 == 7)
+			printf("\n");
+	}
+	printf("};\n");
+
+	return 0;
+}
+
+#endif /* defined(GENERATE) */
diff -u --recursive --new-file v2.1.129/linux/fs/udf/debug.c linux/fs/udf/debug.c
--- v2.1.129/linux/fs/udf/debug.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/debug.c	Sun Nov 29 14:45:28 1998
@@ -0,0 +1,68 @@
+/*
+ * debug.c
+ *
+ * PURPOSE
+ * 	Debugging code.
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ *
+ * HISTORY
+ *	10/4/98 dgb: moved into library
+ */
+
+
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/udf_fs.h>
+
+#ifdef __linux__
+#define PRINT1(X)	printk(KERN_DEBUG X )
+#define PRINT2(X,Y)	printk(KERN_DEBUG X,Y )
+#endif
+
+#else
+#include <sys/types.h>
+#include <stdio.h>
+#include <linux/udf_fs.h>
+#define PRINT1(X)	fprintf(stderr, X )
+#define PRINT2(X,Y)	fprintf(stderr, X,Y )
+#endif
+
+
+void
+udf_dump(char * buffer, int size)
+{
+	char *b;
+	int i, t;
+
+	if (!buffer)
+		return;
+
+	b = buffer;
+
+	for (i = 0; i < size; i += 16) {
+		PRINT2(":%04x ", i);
+		for (t = 0; t < 7; t++)
+			PRINT2("%02x ", b[i + t]);
+		PRINT2("%02x-", b[i + t]);
+		for (; t < 16; t++)
+			PRINT2("%02x ", b[i + t]);
+		for (t = 0; t < 16; t++) {
+			if (b[i + t] >= 0x20U && b[i + t] <= 0x7eU)
+				PRINT2("%c", b[i + t]);
+			else
+				PRINT1(".");
+		}
+		PRINT1("\n");
+	}
+}
diff -u --recursive --new-file v2.1.129/linux/fs/udf/dir.c linux/fs/udf/dir.c
--- v2.1.129/linux/fs/udf/dir.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/dir.c	Sun Nov 29 14:45:28 1998
@@ -0,0 +1,1649 @@
+/*
+ * dir.c
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ *
+ * HISTORY
+ *
+ * 10/5/98 dgb	Split directory operations into it's own file
+ *		Implemented directory reads via do_udf_readdir
+ * 10/6/98	Made directory operations work!
+ * 11/17/98	Rewrote directory to support ICB_FLAG_AD_LONG
+ */
+
+
+#if defined(__linux__) && defined(__KERNEL__)
+#include <linux/version.h>
+#include <linux/udf_fs.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/malloc.h>
+#endif
+
+#include "udfdecl.h"
+
+struct DirectoryCursor {
+	struct buffer_head *  bh;
+	struct buffer_head *  bh_alloc;
+	struct inode * inode;
+	Uint32  currentBlockNum;   /* of directory data */
+	Uint32  dirOffset; 	   /* offset into directory extents */
+	Uint32  allocOffset; 	   /* offset into directory alloc desc */
+	Uint32  extentLength;
+	Uint32  workBufferLength;
+	Uint8   workBuffer[0];
+};
+
+/* directory enumeration and lookups use this */
+static struct DirectoryCursor * udf_fileident_opendir(struct inode *);
+static struct FileIdentDesc * udf_fileident_readdir(struct DirectoryCursor *);
+static void udf_fileident_closedir(struct DirectoryCursor *);
+static int udf_fileident_nextlength(struct DirectoryCursor * );
+
+/* Prototypes for file operations */
+static int udf_readdir(struct file *, void *, filldir_t);
+
+/* generic directory enumeration */
+typedef int (*udf_enum_callback)(struct inode *, struct FileIdentDesc *, 
+	   			void *, void *, void *);
+static int udf_enum_directory(struct inode *, udf_enum_callback, 
+#ifdef BF_CHANGES
+				struct file *, filldir_t, void *,
+				struct FileIdentDesc *);
+#else
+	   			void *, void *, void *);
+#endif
+
+/* readdir and lookup functions */
+static int udf_lookup_callback(struct inode *, struct FileIdentDesc*, 
+	   			void *, void *, void *);
+
+static int udf_readdir_callback(struct inode *, struct FileIdentDesc*, 
+#ifdef BF_CHANGES
+				struct file *, filldir_t, void *);
+#else
+	   			void *, void *, void *);
+#endif
+
+struct file_operations udf_dir_fops = {
+	NULL,			/* llseek */
+	NULL,			/* read */
+	NULL,
+	udf_readdir,		/* readdir */
+	NULL,			/* poll */
+	NULL,			/* ioctl */
+	NULL,			/* mmap */
+	NULL,			/* open */
+	NULL,			/* flush */
+	NULL,			/* release */
+	NULL,			/* fsync */
+	NULL,			/* fasync */
+	NULL,			/* check_media_change */
+	NULL,			/* revalidate */
+	NULL			/* lock */
+};
+
+/*
+ * udf_readdir
+ *
+ * PURPOSE
+ *	Read a directory entry.
+ *
+ * DESCRIPTION
+ *	Optional - sys_getdents() will return -ENOTDIR if this routine is not
+ *	available.
+ *
+ *	Refer to sys_getdents() in fs/readdir.c
+ *	sys_getdents() -> .
+ *
+ * PRE-CONDITIONS
+ *	filp			Pointer to directory file.
+ *	buf			Pointer to directory entry buffer.
+ *	filldir			Pointer to filldir function.
+ *
+ * POST-CONDITIONS
+ *	<return>		>=0 on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+#ifdef BF_CHANGES
+int udf_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct FileIdentDesc *tmpfi;
+	struct inode *dir = filp->f_dentry->d_inode;
+	int result;
+
+	if (!dir)
+	   return -EBADF;
+
+ 	if (!S_ISDIR(dir->i_mode))
+	   return -ENOTDIR;
+
+	if ( filp->f_pos == 0 ) 
+	{
+		if (filldir(dirent, ".", 1, filp->f_pos, dir->i_ino) < 0)
+			return 0;
+	}
+
+ 	if ( filp->f_pos == 0 )
+ 	{
+ 		if (filldir(dirent, ".", 1, filp->f_pos, dir->i_ino) < 0) 
+ 			return 0;
+  	}
+ 
+ 	tmpfi = (struct FileIdentDesc *) __get_free_page(GFP_KERNEL);
+ 
+ 	if (!tmpfi)
+ 		return -ENOMEM;
+ 
+  #ifdef VDEBUG
+ 	printk(KERN_DEBUG "udf: udf_readdir(%p, %p) bs-1 %ld bits-2 %d f_pos (%d/%ld=%d), i_ino=%ld\n",
+ 		filp, dirent,
+ 		(dir->i_sb->s_blocksize - 1), (dir->i_sb->s_blocksize_bits - 2),
+ 		((int)filp->f_pos >> (dir->i_sb->s_blocksize_bits - 2)),
+ 		(((int)filp->f_pos & ((dir->i_sb->s_blocksize - 1) >> 2)) << 2),
+ 		(int)filp->f_pos, dir->i_ino);
+  #endif
+  
+ 	result = udf_enum_directory(dir, udf_readdir_callback, 
+ 					filp, filldir, dirent, tmpfi);
+  
+ 	free_page((unsigned long) tmpfi);
+  	return result;
+}
+
+static int 
+udf_readdir_callback(struct inode *dir, struct FileIdentDesc*fi, 
+ 			struct file  *filp, filldir_t filldir, void *dirent)
+{
+ 	struct ustr filename;
+ 	struct ustr unifilename;
+ 	long ino;
+ 	
+ 	if ( (!fi) || (!filp) || (!filldir) || (!dir) )
+ 	{
+ 		return 0;
+ 	}
+ 
+ 	ino = fi->icb.extLocation.logicalBlockNum;
+ 
+ 	if (fi->lengthFileIdent == 0) /* parent directory */
+ 	{
+ #ifdef VDEBUG
+ 		printk(KERN_DEBUG "udf: readdir callback '%s' (%d) ino %ld == f_pos %d\n",
+ 			"..", 2, filp->f_dentry->d_parent->d_inode->i_ino, (int)filp->f_pos);
+ #endif
+ 		if (filldir(dirent, "..", 2, filp->f_pos, filp->f_dentry->d_parent->d_inode->i_ino) < 0)
+ 			return -1;
+ 		return 0;
+ 	}	
+ 
+ 	if ( udf_build_ustr_exact(&unifilename, fi->fileIdent,
+ 		fi->lengthFileIdent) )
+ 	{
+ 		return 0;
+ 	}
+ 
+ 	if ( udf_CS0toUTF8(&filename, &unifilename) )
+ 	{
+ 		return 0;
+ 	}
+ 
+ #ifdef VDEBUG
+ 	printk(KERN_DEBUG "udf: readdir callback '%s' (%d) ino %ld == f_pos %d\n",
+ 		filename.u_name, filename.u_len, ino, (int)filp->f_pos);
+ #endif
+ 
+ 	if (filldir(dirent, filename.u_name, filename.u_len, filp->f_pos, ino) < 0)
+ 	{
+ 		return 1; /* halt enum */
+ 	}
+ 	return 0;
+}
+
+
+static int 
+udf_enum_directory(struct inode * dir, udf_enum_callback callback, 
+			struct file *filp, filldir_t filldir, void *dirent,
+			struct FileIdentDesc *tmpfi)
+{
+	struct buffer_head *bh;
+	struct FileIdentDesc *fi=NULL;
+	int loffset;
+	int block;
+	int offset;
+	int curtail=0;
+	int remainder=0;
+	int nf_pos = filp->f_pos;
+	int size = (UDF_I_EXT0OFFS(dir) + dir->i_size) >> 2;
+
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: first check: nf_pos %d size %d\n", nf_pos, size);
+#endif
+
+	if (nf_pos >= size)
+		return 1;
+
+	if (nf_pos == 0)
+		nf_pos = (UDF_I_EXT0OFFS(dir) >> 2);
+
+	offset = (nf_pos & ((dir->i_sb->s_blocksize - 1) >> 2)) << 2;
+	block = udf_bmap(dir, nf_pos >> (dir->i_sb->s_blocksize_bits - 2));
+
+	if (!block)
+		return 0;
+	if (!(bh = bread(dir->i_dev, block, dir->i_sb->s_blocksize)))
+		return 0;
+
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: loop started: os %d block %d fp %d size %d\n",
+		 offset, block, nf_pos, size);
+#endif
+
+	while ( (nf_pos < size) && (!curtail) )
+	{
+		filp->f_pos = nf_pos;
+		loffset = offset;
+
+		fi = udf_get_fileident(bh->b_data, dir->i_sb->s_blocksize,
+			&offset, &remainder);
+
+#ifdef VDEBUG
+		printk(KERN_DEBUG "udf: fi %p block %d los %d os %d rem %d fp %d nfp %d\n",
+			fi, block, loffset, offset, remainder, nf_pos, (int)nf_pos + ((offset - loffset) >> 2));
+#endif
+
+		if (!fi)
+		{
+			udf_release_data(bh);
+			return 1;
+		}
+
+		nf_pos += ((offset - loffset) >> 2);
+
+		if (offset == dir->i_sb->s_blocksize)
+		{
+			udf_release_data(bh);
+			block = udf_bmap(dir, nf_pos >> (dir->i_sb->s_blocksize_bits - 2));
+			if (!block)
+				return 0;
+			if (!(bh = bread(dir->i_dev, block, dir->i_sb->s_blocksize)))
+				return 0;
+		}
+		else if (offset > dir->i_sb->s_blocksize)
+		{
+			int fi_len;
+
+			fi = tmpfi;
+
+			remainder = dir->i_sb->s_blocksize - loffset;
+			memcpy((char *)fi, bh->b_data + loffset, remainder);
+
+			udf_release_data(bh);
+			block = udf_bmap(dir, nf_pos >> (dir->i_sb->s_blocksize_bits - 2));
+			if (!block)
+				return 0;
+			if (!(bh = bread(dir->i_dev, block, dir->i_sb->s_blocksize)))
+				return 0;
+
+			if (sizeof(struct FileIdentDesc) > remainder)
+			{
+				memcpy((char *)fi + remainder, bh->b_data, sizeof(struct FileIdentDesc) - remainder);
+
+				if (fi->descTag.tagIdent != TID_FILE_IDENT_DESC)
+				{
+					printk(KERN_DEBUG "udf: (udf_enum_directory) - 0x%x != TID_FILE_IDENT_DESC\n",
+						fi->descTag.tagIdent);
+					udf_release_data(bh);
+					return 1;
+				}
+				fi_len = sizeof(struct FileIdentDesc) + fi->lengthFileIdent + fi->lengthOfImpUse;
+				fi_len += (4 - (fi_len % 4)) % 4;
+				nf_pos += ((fi_len - (offset - loffset)) >> 2);
+			}
+			else
+			{
+				fi_len = sizeof(struct FileIdentDesc) + fi->lengthFileIdent + fi->lengthOfImpUse;
+				fi_len += (4 - (fi_len % 4)) % 4;
+			}
+
+			memcpy((char *)fi + remainder, bh->b_data, fi_len - remainder);
+			offset = fi_len - remainder;
+			remainder = dir->i_sb->s_blocksize - offset;
+		}
+		/* pre-process ident */
+
+		if ( (fi->fileCharacteristics & FILE_DELETED) != 0 )
+		{
+			if ( !udf_undelete ) 
+				continue;
+		}
+		
+		if ( (fi->fileCharacteristics & FILE_HIDDEN) != 0 )
+		{
+			if ( !udf_unhide) 
+				continue;
+		}
+
+		/* callback */
+		curtail = callback(dir, fi, filp, filldir, dirent);
+
+	} /* end while */
+
+	if (!curtail)
+		filp->f_pos = nf_pos;
+
+	if (bh)
+		udf_release_data(bh);
+
+	if ( filp->f_pos >= size)
+		return 1;
+	else
+		return 0;
+}
+
+#else
+
+int udf_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+#if 	LINUX_VERSION_CODE > 0x020140
+	struct inode *dir = filp->f_dentry->d_inode;
+	long ino, parent_ino;
+	int result;
+
+	if (!dir)
+	   return -EBADF;
+
+ 	if (!S_ISDIR(dir->i_mode))
+	   return -ENOTDIR;
+
+	if ( (UDF_I_DIRPOS(dir) == 0) &&
+	   (filp->f_pos > 0) ) {
+	   return 0;
+	}
+	parent_ino=filp->f_dentry->d_parent->d_inode->i_ino;
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: udf_readdir(%p, %p,) DIRPOS %d f_pos %d, i_ino=%ld, parent=%lu\n",
+	   filp, dirent, UDF_I_DIRPOS(dir), (int)filp->f_pos, dir->i_ino, parent_ino);
+#endif
+
+	/* procfs used as an example here */
+	ino = dir->i_ino;
+
+	if ( filp->f_pos == 0 ) {
+	   if (filldir(dirent, ".", 1, filp->f_pos, ino) <0) 
+	   	return 0;
+	   filp->f_pos++;
+	}
+	if ( filp->f_pos == 1 ) {
+	   if (filldir(dirent, "..", 2, filp->f_pos, parent_ino) <0) 
+	   	return 0;
+	   filp->f_pos++;
+	   UDF_I_DIRPOS(dir)=1;
+	}
+
+	result= udf_enum_directory(dir, udf_readdir_callback, 
+	   			filp, filldir, dirent);
+	if ( result )
+	   UDF_I_DIRPOS(dir)=0;
+	return result;
+#else
+	return -1;
+#endif
+}
+
+static int 
+udf_readdir_callback(struct inode *dir, struct FileIdentDesc*fi, 
+	   	void *p1, void *p2, void *p3)
+{
+	struct ustr filename;
+	struct ustr unifilename;
+	long ino;
+	struct file *filp;
+	filldir_t filldir;
+	
+	filp=(struct file*)p1;
+	filldir=(filldir_t)p2;
+
+	if ( (!fi) || (!filp) || (!dir) ) {
+	   printk(KERN_DEBUG "udf: callback failed, line %u\n", __LINE__);
+	   return 0;
+	}
+
+	if ( !filldir ) {
+	   printk(KERN_DEBUG "udf: callback failed, line %u\n", __LINE__);
+	   return 0;
+	}
+	ino=fi->icb.extLocation.logicalBlockNum;
+
+	if ( udf_build_ustr_exact(&unifilename, fi->fileIdent,
+	   fi->lengthFileIdent) ) {
+	   	return 0;
+	}
+
+	if ( udf_CS0toUTF8(&filename, &unifilename) ) {
+	   	return 0;
+	}
+
+	UDF_I_DIRPOS(dir)++;
+	if ( UDF_I_DIRPOS(dir) == (filp->f_pos) ) {
+#ifdef VDEBUG
+	   printk(KERN_DEBUG "udf: readdir %lu callback '%s' dir %d == f_pos\n",
+	   	ino, filename.u_name, UDF_I_DIRPOS(dir));
+#endif
+	   if (filldir(p3, filename.u_name, 	
+	   		filename.u_len, 
+	   		filp->f_pos, ino) <0)
+	   	return 0; /* halt enum */
+	   filp->f_pos++;
+#ifdef VDEBUG
+	} else {
+	   printk(KERN_DEBUG "udf: readdir callback '%s' dir %d != f_pos %d\n",
+	   	filename.u_name, UDF_I_DIRPOS(dir), (int)filp->f_pos);
+#endif
+	}
+	return 0;
+}
+
+static int 
+udf_enum_directory(struct inode * dir, udf_enum_callback callback, 
+	   	void *p1, void *p2, void *p3)
+{
+	struct FileIdentDesc *fi=NULL;
+	struct DirectoryCursor *cursor=NULL;
+	int curtail=0;
+
+	cursor=udf_fileident_opendir(dir);
+	if (!cursor) {
+	   printk(KERN_ERR "udf: enum_directory() failed open, block %lu\n", dir->i_ino);
+	   return 1;
+	}
+
+	while ( (fi=udf_fileident_readdir(cursor)) != NULL ) {
+	   
+	   /* pre-process ident */
+#ifdef VDEBUG
+	   printk(KERN_DEBUG "udf: enum_dir %lu ino %lu fi %p char %x lenident %d\n",
+		(long)cursor->inode->i_ino,
+		(long)fi->icb.extLocation.logicalBlockNum,
+		(void *)fi, fi->fileCharacteristics, fi->lengthFileIdent);
+#endif
+
+	   if ( !fi->lengthFileIdent )
+	   	continue;
+
+	   if ( (fi->fileCharacteristics & FILE_DELETED) != 0 ) {
+	   	if ( !udf_undelete ) 
+	   		continue;
+	   }
+	   
+	   if ( (fi->fileCharacteristics & FILE_HIDDEN) != 0 ) {
+	   	if ( !udf_unhide) 
+	   		continue;
+	   }
+
+	   /* callback */
+	   curtail=callback(dir, fi, p1, p2, p3);
+	} /* end while */
+
+	udf_fileident_closedir(cursor);
+	return curtail ? 0 : 1;
+}
+
+#if 0
+int udf_readdir(struct file *filp, void *dirent, filldir_t filldir)
+{
+	struct FileIdentDesc *tmpfi;
+	struct inode *dir = filp->f_dentry->d_inode;
+	long ino, parent_ino;
+	int result;
+
+	if (!dir)
+	   return -EBADF;
+
+ 	if (!S_ISDIR(dir->i_mode))
+	   return -ENOTDIR;
+
+	if ( (UDF_I_DIRPOS(dir) == 0) &&
+	   (filp->f_pos > 0) ) {
+	   return 0;
+	}
+	parent_ino=filp->f_dentry->d_parent->d_inode->i_ino;
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: udf_readdir(%p, %p,) DIRPOS %d f_pos %d, i_ino=%ld, parent=%lu\n",
+	   filp, dirent, UDF_I_DIRPOS(dir), (int)filp->f_pos, dir->i_ino, parent_ino);
+#endif
+
+	/* procfs used as an example here */
+	ino = dir->i_ino;
+
+	if ( filp->f_pos == 0 ) {
+	   if (filldir(dirent, ".", 1, filp->f_pos, ino) <0) 
+	   	return 0;
+	   filp->f_pos++;
+	}
+	if ( filp->f_pos == 1 ) {
+	   if (filldir(dirent, "..", 2, filp->f_pos, parent_ino) <0) 
+	   	return 0;
+	   filp->f_pos++;
+	   UDF_I_DIRPOS(dir)=1;
+	}
+
+	result= udf_enum_directory(dir, udf_readdir_callback, 
+	   			filp, filldir, dirent);
+	if ( result )
+	   UDF_I_DIRPOS(dir)=0;
+	return result;
+}
+
+static int 
+udf_readdir_callback(struct inode *dir, struct FileIdentDesc*fi, 
+	   	void *p1, void *p2, void *p3)
+{
+	struct ustr filename;
+	struct ustr unifilename;
+	long ino;
+	struct file *filp;
+	filldir_t filldir;
+	
+	filp=(struct file*)p1;
+	filldir=(filldir_t)p2;
+
+	if ( (!fi) || (!filp) || (!dir) ) {
+	   printk(KERN_DEBUG "udf: callback failed, line %u\n", __LINE__);
+	   return 0;
+	}
+
+	if ( !filldir ) {
+	   printk(KERN_DEBUG "udf: callback failed, line %u\n", __LINE__);
+	   return 0;
+	}
+	ino=fi->icb.extLocation.logicalBlockNum;
+
+	if ( udf_build_ustr_exact(&unifilename, fi->fileIdent,
+	   fi->lengthFileIdent) ) {
+	   	return 0;
+	}
+
+	if ( udf_CS0toUTF8(&filename, &unifilename) ) {
+	   	return 0;
+	}
+
+	UDF_I_DIRPOS(dir)++;
+	if ( UDF_I_DIRPOS(dir) == (filp->f_pos) ) {
+#ifdef VDEBUG
+	   printk(KERN_DEBUG "udf: readdir %lu callback '%s' dir %d == f_pos\n",
+	   	ino, filename.u_name, UDF_I_DIRPOS(dir));
+#endif
+	   if (filldir(p3, filename.u_name, 	
+	   		filename.u_len, 
+	   		filp->f_pos, ino) <0)
+	   	return 0; /* halt enum */
+	   filp->f_pos++;
+#ifdef VDEBUG
+	} else {
+	   printk(KERN_DEBUG "udf: readdir callback '%s' dir %d != f_pos %d\n",
+	   	filename.u_name, UDF_I_DIRPOS(dir), (int)filp->f_pos);
+#endif
+	}
+	return 0;
+}
+
+static int 
+udf_enum_directory(struct inode * dir, udf_enum_callback callback, 
+	   	void *p1, void *p2, void *p3)
+{
+	struct FileIdentDesc *fi=NULL;
+	struct DirectoryCursor *cursor=NULL;
+	int curtail=0;
+
+	cursor=udf_fileident_opendir(dir);
+	if (!cursor) {
+	   printk(KERN_ERR "udf: enum_directory() failed open, block %lu\n", dir->i_ino);
+	   return 1;
+	}
+
+	while ( (fi=udf_fileident_readdir(cursor)) != NULL ) {
+	   
+	   /* pre-process ident */
+#ifdef VDEBUG
+	   printk(KERN_DEBUG "udf: enum_dir %lu ino %lu fi %p char %x lenident %d\n",
+		(long)cursor->inode->i_ino,
+		(long)fi->icb.extLocation.logicalBlockNum,
+		(void *)fi, fi->fileCharacteristics, fi->lengthFileIdent);
+#endif
+
+	   if ( !fi->lengthFileIdent )
+	   	continue;
+
+	   if ( (fi->fileCharacteristics & FILE_DELETED) != 0 ) {
+	   	if ( !udf_undelete ) 
+	   		continue;
+	   }
+	   
+	   if ( (fi->fileCharacteristics & FILE_HIDDEN) != 0 ) {
+	   	if ( !udf_unhide) 
+	   		continue;
+	   }
+
+	   /* callback */
+	   curtail=callback(dir, fi, p1, p2, p3);
+	} /* end while */
+
+	udf_fileident_closedir(cursor);
+	return curtail ? 0 : 1;
+}
+#endif
+#endif /* def BF_CHANGES */
+
+static struct DirectoryCursor * 
+udf_fileident_opendir(struct inode *dir)
+{
+	struct DirectoryCursor * cursor;
+	struct FileEntry *fe;
+	int buildsize;
+	int block;
+
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: opendir %lu\n", dir->i_ino);
+#endif
+
+	if ( (!dir) || (!dir->i_sb) || (!S_ISDIR(dir->i_mode)) ) {
+	   printk(KERN_ERR "udf: invalid inode sent to opendir\n");
+	   return NULL;
+	}
+
+	buildsize=sizeof(struct DirectoryCursor) + (dir->i_sb->s_blocksize);
+	cursor=(struct DirectoryCursor *) kmalloc( buildsize, GFP_KERNEL);
+	if (!cursor) {
+	   printk(KERN_ERR "udf: can't kmalloc work buffer\n");
+	   return NULL;
+	}
+
+	cursor->inode=dir;
+
+	block=udf_block_from_inode(cursor->inode->i_sb, cursor->inode->i_ino);
+	cursor->bh=udf_read_tagged(cursor->inode->i_sb, block, 
+	   			UDF_BLOCK_OFFSET(cursor->inode->i_sb));
+	if (!cursor->bh) {
+	   printk(KERN_ERR "udf: can't read directory block %u\n", block);
+	   kfree(cursor);
+	   return NULL;
+	}
+	cursor->currentBlockNum= block;
+
+	/* used by AD_LONG */
+	cursor->bh_alloc=NULL; 
+
+	/* workBuffer is for fileentry's that span blocks */
+	/* all other entries will be read directly from bh->b_data */
+	cursor->workBufferLength= dir->i_sb->s_blocksize;	
+	cursor->dirOffset=0;
+	cursor->allocOffset=0;
+
+	fe=(struct FileEntry *)cursor->bh->b_data;
+
+	switch (UDF_I_ALLOCTYPE(cursor->inode)) {
+
+	  case ICB_FLAG_AD_SHORT:
+	   printk(KERN_DEBUG "udf: unexpected ICB_FLAG_AD_SHORT dir %u\n", 
+			block);
+	   udf_fileident_closedir(cursor);
+	   return NULL;
+
+	  case ICB_FLAG_AD_EXTENDED:
+	   printk(KERN_DEBUG "udf: unexpected ICB_FLAG_AD_EXTENTED dir %u\n", 
+			block);
+	   udf_fileident_closedir(cursor);
+	   return NULL;
+
+	  case ICB_FLAG_AD_LONG:
+	   { /* setup initial info */
+	   	long_ad * la;
+	   	la=udf_get_filelongad(fe, 
+			cursor->inode->i_sb->s_blocksize, 
+			&cursor->allocOffset);
+	   	if ( (la) && (la->extLength) ) {
+	   		cursor->extentLength=la->extLength;
+	   		cursor->currentBlockNum=la->extLocation.logicalBlockNum;
+	   		cursor->bh_alloc=cursor->bh;
+	   		cursor->bh=udf_read_untagged(cursor->inode->i_sb, 
+	   				cursor->currentBlockNum,
+	   				UDF_BLOCK_OFFSET(cursor->inode->i_sb));
+	   	} else {
+#ifdef DEBUG
+		   printk(KERN_DEBUG "udf: readdir %lu AD_LONG no extents\n",
+			cursor->inode->i_ino);
+	   	   udf_fileident_closedir(cursor);
+#endif
+		   return NULL;
+		}
+	   }
+#ifdef DEBUG
+	   printk(KERN_DEBUG "udf: dir %lu AD_LONG ext[0] -> %d size %u\n", 
+	   	cursor->inode->i_ino, cursor->currentBlockNum,
+		cursor->extentLength);
+#endif
+	   break;
+
+	  case ICB_FLAG_AD_IN_ICB:
+	   cursor->extentLength=fe->lengthAllocDescs;
+	   cursor->dirOffset=(int)fe->extendedAttr - (int)fe +
+	   			fe->lengthExtendedAttr;
+#ifdef DEBUG
+	   printk(KERN_DEBUG "udf: dir %lu AD_IN_ICB size %u\n", 
+	   	cursor->inode->i_ino, cursor->extentLength);
+#endif
+	   break;
+
+	}
+	return cursor;
+}
+
+static struct FileIdentDesc * 
+udf_fileident_readdir(struct DirectoryCursor * cursor)
+{
+	struct FileEntry * fe;
+	struct FileIdentDesc * fi;
+	long_ad * la;
+	Uint8 * ptr;
+	int lengthThisIdent;
+	int remainder=0;
+
+	if ( (!cursor) || (!cursor->bh) )
+	   return NULL;
+
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: readdir %lu, extlen %d\n", 
+		cursor->inode->i_ino, cursor->extentLength);
+#endif
+	if ( (int)cursor->extentLength < 0 ) {
+	   printk(KERN_ERR "udf: programmer malfunction - lengthIdents negative! line %u\n",
+	   	__LINE__);
+	   return NULL;
+	}
+
+	switch ( UDF_I_ALLOCTYPE(cursor->inode) ) {
+	   case ICB_FLAG_AD_LONG:
+	   	fe=(struct FileEntry *)cursor->bh_alloc->b_data;
+	   	break;
+	   case ICB_FLAG_AD_IN_ICB:
+		if ( !cursor->extentLength ) 
+			return NULL;
+	   	fe=(struct FileEntry *)cursor->bh->b_data;
+	   	break;
+	   default:
+	   	printk(KERN_DEBUG "udf: huh? line %u\n", __LINE__);
+	   	return NULL;
+	}
+
+	cursor->workBufferLength=0;
+	remainder=cursor->inode->i_sb->s_blocksize - cursor->dirOffset;
+	ptr=(Uint8 *)cursor->bh->b_data + cursor->dirOffset;
+
+	lengthThisIdent=udf_fileident_nextlength(cursor);
+#ifdef VDEBUG
+	printk(KERN_DEBUG 
+	   "udf: dirOffset %d lengthThisIdent %d remainder %d extLen %d\n",
+	   cursor->dirOffset, lengthThisIdent, remainder, cursor->extentLength);
+#endif
+
+	if ( lengthThisIdent < 1 ) {
+	   /* refill our buffers */
+	   remainder=cursor->inode->i_sb->s_blocksize - cursor->dirOffset;
+#ifdef VDEBUG
+	   printk(KERN_DEBUG "udf: refill needed %lu len %d type %u\n",
+		cursor->inode->i_ino, remainder,
+		UDF_I_ALLOCTYPE(cursor->inode));
+#endif
+
+	   if ( UDF_I_ALLOCTYPE(cursor->inode) == ICB_FLAG_AD_LONG ) {
+	   	/* copy fragment into workBuffer */
+	   	memcpy(cursor->workBuffer, ptr, remainder);
+	   	cursor->workBufferLength=remainder;
+
+	   	/* release old buffer */
+	   	udf_release_data(cursor->bh);
+	   	cursor->bh=NULL;
+
+	   	/* calculate new block number */
+	   	if ( cursor->extentLength > cursor->inode->i_sb->s_blocksize) {
+	   		cursor->extentLength -= cursor->inode->i_sb->s_blocksize;
+	   		cursor->currentBlockNum++;
+#ifdef VDEBUG
+			printk(KERN_DEBUG "udf: refill %lu ext %u len %d\n",
+				cursor->inode->i_ino, 
+				cursor->currentBlockNum,
+				cursor->extentLength);
+#endif
+	   	} else { /* need next extent */
+	   		la=udf_get_filelongad(fe, 
+	   			cursor->inode->i_sb->s_blocksize, 
+	   			&cursor->allocOffset);
+	   		if ( (la) && (la->extLength) ) {
+	   			cursor->currentBlockNum=la->extLocation.logicalBlockNum;
+	   			cursor->extentLength=la->extLength;
+#ifdef DEBUG
+				printk(KERN_DEBUG 
+				  "udf: dir %lu AD_LONG ext[] -> %u len %d\n",
+				cursor->inode->i_ino, 
+				cursor->currentBlockNum,
+				cursor->extentLength);
+#endif
+	   		} else {
+#ifdef DEBUG
+		   	   printk(KERN_DEBUG 
+				"udf: dir %lu AD_LONG ext[] end\n",
+				cursor->inode->i_ino);
+#endif
+				return NULL;
+			}
+	   	}
+
+	   	/* get new buffer */
+	   	cursor->bh=udf_read_untagged(cursor->inode->i_sb,
+	   			cursor->currentBlockNum,
+	   			UDF_BLOCK_OFFSET(cursor->inode->i_sb));
+	   	if (!cursor->bh) {
+	   	   printk(KERN_ERR "udf: can't read directory block %lu\n",
+			(long)cursor->currentBlockNum);
+	   	   return NULL;
+	   	}
+
+	   	/* merge other fragment into workBuffer */
+	   	memcpy(cursor->workBuffer+cursor->workBufferLength,
+	   		cursor->bh->b_data, 
+	   		(cursor->inode->i_sb->s_blocksize - remainder));
+
+	   	/* use workBuffer instead of b_data for this one */
+	   	ptr=cursor->workBuffer;
+	   	cursor->dirOffset=0;
+	   	lengthThisIdent=udf_fileident_nextlength(cursor);
+
+	   	/* adjust dirOffset for fragment */
+	   	cursor->dirOffset = lengthThisIdent - cursor->workBufferLength;
+		cursor->extentLength -= cursor->dirOffset;
+	   	cursor->workBufferLength= 0;
+
+#ifdef VDEBUG
+	   	printk(KERN_DEBUG "udf: merged fi size %d, dirOffset %d\n", 
+			lengthThisIdent, cursor->dirOffset);
+#endif
+	   } else {
+	   	printk(KERN_DEBUG "udf: alloc type? line %u rem %d type %d\n", 
+	   		__LINE__, remainder, UDF_I_ALLOCTYPE(cursor->inode));
+	   	return NULL;
+	   }
+	} else {
+	   /* not a fragment */
+	   cursor->dirOffset += lengthThisIdent;	
+	   cursor->extentLength -= lengthThisIdent;
+	}
+
+	if ( lengthThisIdent < 0 ) {
+		printk(KERN_DEBUG "udf: readdir len %d??\n", lengthThisIdent);
+		return NULL;
+	}
+
+	fi=(struct FileIdentDesc *)ptr;
+	if ( fi->descTag.tagIdent != TID_FILE_IDENT_DESC )
+		return NULL;
+
+	return fi;
+}
+
+static void 
+udf_fileident_closedir(struct DirectoryCursor * cursor)
+{
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: closedir %lu\n",
+		cursor->inode->i_ino);
+#endif
+	if ( cursor->bh )
+	   udf_release_data(cursor->bh);
+	if ( cursor->bh_alloc )
+	   udf_release_data(cursor->bh_alloc);
+	kfree(cursor);
+}
+
+/*
+ * returns: -1 if refill needed, otherwise size of ident
+ */
+static int
+udf_fileident_nextlength(struct DirectoryCursor * cursor)
+{
+	struct FileIdentDesc * fi;
+	Uint8 * ptr;
+	int lengthThisIdent;
+	int padlen;
+	int remainder;
+
+	if ( !cursor->bh )
+	   return -1;
+
+	if ( cursor->extentLength < 1 ) 
+	   return -1;
+
+	if ( !cursor->workBufferLength ) {
+	   /* check for refill */
+	   remainder=cursor->inode->i_sb->s_blocksize - cursor->dirOffset;
+	   if ( remainder < sizeof(struct FileIdentDesc) )
+	   	return -1;
+
+	   ptr=(Uint8 *)cursor->bh->b_data + cursor->dirOffset;
+	} else {
+	   ptr=cursor->workBuffer;
+	}
+	fi=(struct FileIdentDesc *)ptr;
+
+	lengthThisIdent=sizeof(struct FileIdentDesc) +
+	   	fi->lengthFileIdent + fi->lengthOfImpUse;
+
+	padlen=lengthThisIdent % UDF_NAME_PAD;  /* should be 4 ? */
+	if ( padlen )
+	   lengthThisIdent += (UDF_NAME_PAD - padlen);
+
+	if ( (cursor->workBufferLength) ||
+	     ( (cursor->dirOffset+lengthThisIdent) < cursor->inode->i_sb->s_blocksize) )
+	   return lengthThisIdent;
+	else
+	   return -1;
+}
+
+/* Inode Operations */
+
+#ifdef CONFIG_UDF_WRITE
+static int udf_link(struct inode *, struct inode *, struct dentry *);
+static int udf_unlink(struct inode *, struct dentry *);
+static int udf_symlink(struct inode *, struct dentry *, const char *);
+static int udf_mkdir(struct inode *, struct dentry *, int);
+static int udf_rmdir(struct inode *, struct dentry *);
+static int udf_mknod(struct inode *, struct dentry *, ints, int);
+static int udf_rename(struct inode *, struct dentry *, struct inode *,
+	struct dentry *);
+#endif
+
+#ifdef CONFIG_UDF_FULL_FS
+static int udf_readlink(struct inode *, char *, int);
+static struct dentry * udf_follow_link(struct inode *, struct dentry *);
+static int udf_permission(struct inode *, int);
+static int udf_smap(struct inode *, int);
+#endif
+
+/*
+ * udf_lookup
+ *
+ * PURPOSE
+ *	Look-up the inode for a given name.
+ *
+ * DESCRIPTION
+ *	Required - lookup_dentry() will return -ENOTDIR if this routine is not
+ *	available for a directory. The filesystem is useless if this routine is
+ *	not available for at least the filesystem's root directory.
+ *
+ *	This routine is passed an incomplete dentry - it must be completed by
+ *	calling d_add(dentry, inode). If the name does not exist, then the
+ *	specified inode must be set to null. An error should only be returned
+ *	when the lookup fails for a reason other than the name not existing.
+ *	Note that the directory inode semaphore is held during the call.
+ *
+ *	Refer to lookup_dentry() in fs/namei.c
+ *	lookup_dentry() -> lookup() -> real_lookup() -> .
+ *
+ * PRE-CONDITIONS
+ *	dir			Pointer to inode of parent directory.
+ *	dentry			Pointer to dentry to complete.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+#ifdef BF_CHANGES
+
+int
+udf_lookup(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode=NULL;
+	long ino=0;
+	struct file filp;
+	struct FileIdentDesc *tmpfi;
+
+	filp.f_pos = 0;
+	tmpfi = (struct FileIdentDesc *) __get_free_page(GFP_KERNEL);
+	if (!tmpfi)
+		return -ENOMEM;
+
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: udf_lookup(%lu, '%s')\n",
+		dir->i_ino, dentry->d_name.name);
+#endif
+
+	udf_enum_directory(dir, udf_lookup_callback, &filp, &ino, (void *)dentry, tmpfi);
+
+	free_page((unsigned long) tmpfi);
+
+	if ( ino )
+	{
+		inode = udf_iget(dir->i_sb, ino);
+		if ( !inode )
+			return -EACCES;
+	}
+	d_add(dentry, inode);
+	return 0;
+}
+
+#else
+
+int
+udf_lookup(struct inode *dir, struct dentry *dentry)
+{
+	struct inode *inode=NULL;
+	long ino=0;
+
+	/* Temporary - name doesn't exist, but it is okay to create it */
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf: udf_lookup(%lu, '%s')\n",
+	   dir->i_ino, dentry->d_name.name);
+#endif
+#ifdef DEBUG
+	/* temporary shorthand for specifying files by inode number */
+	if ( !strncmp(dentry->d_name.name, ".I=", 3) ) {
+	   ino=simple_strtoul(dentry->d_name.name+3, NULL, 0);
+	}
+#endif
+	udf_enum_directory(dir, udf_lookup_callback, (void *)dentry, &ino, NULL);
+	if ( ino ) {
+	   inode = udf_iget(dir->i_sb, ino);
+	   if ( !inode )
+	   	return -EACCES;
+	}
+	d_add(dentry, inode);
+	return 0;
+}
+#endif
+
+static int
+udf_lookup_callback(struct inode *dir, struct FileIdentDesc *fi, 
+#ifdef BF_CHANGES
+		void *unused3, void *parm2, void *parm1)
+#else
+	   	void *parm1, void *parm2, void *unused3)
+#endif
+{
+	struct dentry * dentry;
+	long *ino;
+	struct ustr filename;
+	struct ustr unifilename;
+
+	dentry=(struct dentry *)parm1;
+	ino=(long *)parm2;
+
+	if ( (!dir) || (!fi) || (!dentry) || (!ino) )
+	   return 0;
+
+	if (!fi->lengthFileIdent)
+		return 0;
+
+	if ( udf_build_ustr_exact(&unifilename, fi->fileIdent,
+	   fi->lengthFileIdent) ) {
+	   	return 0;
+	}
+
+	if ( udf_CS0toUTF8(&filename, &unifilename) ) {
+	   	return 0;
+	}
+
+	if ( strcmp(dentry->d_name.name, filename.u_name) == 0) {
+	   *ino = fi->icb.extLocation.logicalBlockNum;
+	   return 1; /* stop enum */
+	}
+	return 0; /* continue enum */
+}
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_link
+ *
+ * PURPOSE
+ *	Create a hard link.
+ *
+ * DESCRIPTION
+ *	This routine is passed an incomplete dentry - it doesn't have an
+ *	assigned inode, so one must be assigned by calling:
+ *		d_instantiate(dentry, inode)
+ *
+ * PRE-CONDITIONS
+ *	inode			Pointer to inode of file to link to.
+ *	dir			Pointer to inode of parent directory.
+ *	dentry			Pointer to dentry of new link.
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_link(struct inode *inode, struct inode *dir, struct dentry *dentry)
+{
+	return -1;
+}
+
+/*
+ * udf_unlink
+ *
+ * PURPOSE
+ *	Unlink (remove) an inode.
+ *
+ * DESCRIPTION
+ *	Call d_delete(dentry) when ready to delete the dentry and inode.
+ *
+ * PRE-CONDITIONS
+ *	dir			Pointer to inode of parent directory.
+ *	dentry			Pointer to dentry to unlink.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_unlink(struct inode *dir, struct dentry *dentry)
+{
+	return -1;
+}
+
+/*
+ * udf_symlink
+ *
+ * PURPOSE
+ *	Create a symbolic link.
+ *
+ * DESCRIPTION
+ *	This routine is passed an incomplete dentry - it doesn't have an
+ *	assigned inode, so one must be assigned by calling:
+ *		d_instantiate(dentry, inode)
+ *
+ * PRE-CONDITIONS
+ *	dir			Pointer to inode of parent directory.
+ *	dentry			Pointer to dentry of new symlink.
+ *	symname			Pointer to symbolic name of new symlink.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
+{
+	return -1;
+}
+
+/*
+ * udf_mkdir
+ *
+ * PURPOSE
+ *	Create a directory.
+ *
+ * DESCRIPTION
+ *	This routine is passed an incomplete dentry - it doesn't have an
+ *	assigned inode, so one must be assigned by calling:
+ *		d_instantiate(dentry, inode)
+ *
+ *	Refer to sys_mkdir() in fs/namei.c
+ *	sys_mkdir() -> do_mkdir() -> .
+ *
+ * PRE-CONDITIONS
+ *	dir			Pointer toinode of parent directory.
+ *	dentry			Pointer to dentry of new directory.
+ *	mode			Mode of new directory.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return -1;
+}
+
+/*
+ * udf_rmdir
+ *
+ * PURPOSE
+ *	Remove a directory.
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *	dir			Pointer to inode of parent directory.
+ *	dentry			Pointer to dentry of directory to remove.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	return -1;
+}
+
+/*
+ * udf_mknod
+ *
+ * PURPOSE
+ *	Make a special node.
+ *
+ * DESCRIPTION
+ *	Optional - sys_mknod() will retrun -EPERM if this routine is not
+ *	available.
+ *
+ *	This routine is passed an incomplete dentry - it doesn't have an
+ *	assigned inode, so one must be assigned by calling:
+ *		d_instantiate(dentry, inode)
+ *
+ *	Note that only root is allowed to create sockets and device files.
+ *
+ *	Refer to sys_mknod() in fs/namei.c
+ *	sys_mknod() -> do_mknod() -> .
+ *
+ * PRE-CONDITIONS
+ *	dir			Pointer to inode of parent directory.
+ *	dentry			Pointer to dentry of new node.
+ *	mode			Mode of new node.
+ *	rdev			Real device of new node.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_mknod(struct inode *dir, struct dentry *dentry, int mode, int rdev)
+{
+	return -1;
+}
+
+/*
+ * udf_rename
+ *
+ * PURPOSE
+ *	Rename an existing inode.
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *	old_dir			Pointer to inode of old parent directory.
+ *	old_dentry		Pointer to old dentry.
+ *	new_dir			Pointer to inode of new parent directory.
+ *	new_dentry		Pointer to new dentry.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_rename(struct inode *inode, struct dentry *dentry, struct inode *, struct dentry *)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_FULL_FS
+/*
+ * udf_readlink
+ *
+ * PURPOSE
+ *	Read the contents of a symbolic link.
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *	inode			Pointer to inode of link.
+ *	buf			Pointer to buffer for name.
+ *	buf_size		Size of buffer.
+ *	
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_readlink(struct inode *inode, char *buf, int buf_size)
+{
+	return -1;
+}
+
+/*
+ * udf_follow_link
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static struct dentry *
+udf_follow_link(struct inode *inode, struct dentry *dentry)
+{
+	return ERR_PTR(-1);
+}
+#endif
+
+
+/* Inode Operations */
+#ifdef CONFIG_UDF_WRITE
+static int udf_create(struct inode *, struct dentry *, int);
+static int udf_link(struct inode *, struct inode *, struct dentry *);
+static int udf_unlink(struct inode *, struct dentry *);
+static int udf_symlink(struct inode *, struct dentry *, const char *);
+static int udf_mkdir(struct inode *, struct dentry *, int);
+static int udf_rmdir(struct inode *, struct dentry *);
+static int udf_mknod(struct inode *, struct dentry *, ints, int);
+static int udf_rename(struct inode *, struct dentry *, struct inode *,
+	struct dentry *);
+static int udf_writepage(struct inode *, struct page *);
+static void udf_truncate(struct inode *);
+static int udf_updatepage(struct inode *, struct page *, const char *,
+	unsigned long, unsigned int, int);
+static int udf_revalidate(struct inode *);
+#endif
+
+#ifdef CONFIG_UDF_FULL_FS
+static int udf_readlink(struct inode *, char *, int);
+static struct dentry * udf_follow_link(struct inode *, struct dentry *);
+static int udf_readpage(struct inode *, struct page *);
+static int udf_permission(struct inode *, int);
+static int udf_smap(struct inode *, int);
+#endif
+
+
+struct inode_operations udf_dir_inode_operations= {
+	&udf_dir_fops,
+#ifdef CONFIG_UDF_WRITE
+	NULL,			/* create */
+	udf_lookup,		/* lookup */
+	udf_link,		/* link */
+	udf_unlink,		/* unlink */
+	udf_symlink,		/* symlink */
+	udf_mkdir,		/* mkdir */
+	udf_rmdir,		/* rmdir */
+	udf_mknod,		/* mknod */
+	udf_rename,		/* rename */
+	udf_readlink,		/* readlink */
+	udf_follow_link,	/* follow_link */
+	NULL,			/* readpage */
+	NULL,			/* writepage */
+	udf_bmap,		/* bmap */
+	NULL,			/* truncate */
+	udf_permission,		/* permission */
+	NULL,			/* smap */
+	NULL,			/* updatepage */
+	NULL,			/* revalidate */
+#else
+	NULL,			/* create */
+	udf_lookup,		/* lookup */
+	NULL,			/* link */
+	NULL,			/* unlink */
+	NULL,			/* symlink */
+	NULL,			/* mkdir */
+	NULL,			/* rmdir */
+	NULL,			/* mknod */
+	NULL,			/* rename */
+	NULL,			/* readlink */
+	NULL,			/* follow_link */
+	NULL,			/* readpage */
+	NULL,			/* writepage */
+	NULL,		/* bmap */
+	NULL,			/* truncate */
+#ifdef CONFIG_UDF_FULL_FS
+	udf_permission,		/* permission */
+#else
+	NULL,
+#endif
+	NULL,			/* smap */
+	NULL,			/* updatepage */
+	NULL			/* revalidate */
+#endif
+};
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_create
+ *
+ * PURPOSE
+ *	Create an inode.
+ *
+ * DESCRIPTION
+ *	Optional - sys_open() will return -EACCESS if not available.
+ *
+ *	This routine is passed an incomplete dentry - it doesn't have an
+ *	assigned inode, so one must be assigned by calling:
+ *		d_instantiate(dentry, inode)
+ *
+ *	Refer to sys_open() in fs/open.c and open_namei() in fs/namei.c
+ *	sys_open() -> do_open() -> open_namei() -> .
+ *
+ * PRE-CONDITIONS
+ *	dir			Pointer to inode of parent directory.
+ *	dentry			Pointer to dentry to complete.
+ *	mode			Mode of new inode.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_create(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_readpage
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *	Used for memory mapping. See generic_readpage() in fs/buffer.c for
+ *	filesystems that support the bmap() operation.
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_readpage(struct inode *inode, struct page *)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_writepage
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *	Used for memory mapping. Required if readpage() is defined.
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_writepage(struct inode *inode, struct page *)
+{
+	return -1;
+}
+
+
+/*
+ * udf_truncate
+ *
+ * PURPOSE
+ *	Truncate a file.
+ *
+ * DESCRIPTION
+ *	This routine is called by sys_truncate() to reduce the size of a file.
+ *
+ * PRE-CONDITIONS
+ *	inode			Pointer to inode of file to truncate.
+ *
+ * POST-CONDITIONS
+ *	None.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static void
+udf_truncate(struct inode *inode)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_FULL_FS
+/*
+ * udf_permissions
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_permission(struct inode *inode, int)
+{
+	return -1;
+}
+
+/*
+ * udf_smap
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_smap(struct inode *inode, int)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_updatepage
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_updatepage(struct inode *inode, struct page *, const char *, unsigned long, unsigned int, int)
+{
+	return -1;
+}
+
+/*
+ *
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_revalidate(struct inode *inode)
+{
+	return -1;
+}
+#endif
diff -u --recursive --new-file v2.1.129/linux/fs/udf/directory.c linux/fs/udf/directory.c
--- v2.1.129/linux/fs/udf/directory.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/directory.c	Sun Nov 29 14:45:28 1998
@@ -0,0 +1,205 @@
+/*
+ * directory.c
+ *
+ * PURPOSE
+ *	Directory related functions
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ */
+
+
+#if defined(__linux__) && defined(__KERNEL__)
+
+#include <linux/fs.h>
+#include <linux/udf_fs.h>
+
+#else
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <linux/udf_fs.h>
+
+#endif
+
+struct FileIdentDesc * 
+udf_get_fileident(void * buffer, int bufsize, int * offset, int * remainder)
+{
+	struct FileIdentDesc *fi;
+	int lengthThisIdent;
+	Uint8 * ptr;
+	int padlen;
+
+	if ( (!buffer) || (!offset) ) {
+#ifdef __KERNEL__
+		printk(KERN_DEBUG "udf: udf_get_fileident() invalidparms\n");
+#endif
+		return NULL;
+	}
+
+	ptr = buffer;
+
+	if ( (*offset + sizeof(tag)) > bufsize )
+	{
+		/* This should not be legal, but it is done... */
+#if 0
+#ifdef __KERNEL__
+		printk(KERN_DEBUG 
+			"udf: udf_get_fileident() buffer too short (%u + %u > %u)\n", *offset, sizeof(tag), bufsize);
+#endif
+		return NULL;
+#endif
+	}
+
+	if ( (*offset > 0) && (*offset < bufsize) ) {
+		ptr += *offset;
+	}
+	fi=(struct FileIdentDesc *)ptr;
+	if (fi->descTag.tagIdent != TID_FILE_IDENT_DESC)
+	{
+#ifdef __KERNEL__
+		printk(KERN_DEBUG "udf: _fileident - 0x%x != TID_FILE_IDENT_DESC\n",
+			fi->descTag.tagIdent);
+		printk(KERN_DEBUG "udf: offset: %u sizeof: %u bufsize: %u\n",
+			*offset, sizeof(struct FileIdentDesc), bufsize);
+		return NULL;
+#endif
+	}
+	if ( (*offset + sizeof(struct FileIdentDesc)) > bufsize )
+	{
+		lengthThisIdent = sizeof(struct FileIdentDesc);
+	}
+	else
+		lengthThisIdent=sizeof(struct FileIdentDesc) +
+			fi->lengthFileIdent + fi->lengthOfImpUse;
+
+	/* we need to figure padding, too! */
+	padlen=lengthThisIdent % UDF_NAME_PAD;
+	if (padlen)
+		lengthThisIdent+= (UDF_NAME_PAD - padlen);
+	*offset = *offset + lengthThisIdent;
+	if ( remainder ) {
+		*remainder=bufsize - *offset;
+	}
+
+	return fi;
+}
+
+extent_ad *
+udf_get_fileextent(void * buffer, int bufsize, int * offset)
+{
+	extent_ad * ext;
+	struct FileEntry *fe;
+	int lengthExtents;
+	Uint8 * ptr;
+
+	if ( (!buffer) || (!offset) ) {
+#ifdef __KERNEL__
+		printk(KERN_ERR "udf: udf_get_fileextent() invalidparms\n");
+#endif
+		return NULL;
+	}
+
+	fe=(struct FileEntry *)buffer;
+	if ( fe->descTag.tagIdent != TID_FILE_ENTRY ) {
+#ifdef __KERNEL__
+		printk(KERN_DEBUG "udf: _fileextent - 0x%x != TID_FILE_ENTRY\n",
+			fe->descTag.tagIdent);
+#endif
+		return NULL;
+	}
+	lengthExtents = fe->lengthAllocDescs;
+
+	ptr=(Uint8 *)(fe->extendedAttr);
+	ptr += fe->lengthExtendedAttr;
+
+	if ( (*offset > 0) && (*offset < lengthExtents) ) {
+		ptr += *offset;
+	}
+	ext=(extent_ad *)ptr;
+
+	*offset = *offset + sizeof(extent_ad);
+	return ext;
+}
+
+short_ad *
+udf_get_fileshortad(void * buffer, int bufsize, int * offset)
+{
+	short_ad * sa;
+	struct FileEntry *fe;
+	int lengthShortAds;
+	Uint8 * ptr;
+	if ( (!buffer) || (!offset) ) {
+#ifdef __KERNEL__
+                printk(KERN_ERR "udf: udf_get_fileshortad() invalidparms\n");
+#endif
+		return NULL;
+	}
+	fe=(struct FileEntry *)buffer;
+	if ( fe->descTag.tagIdent != TID_FILE_ENTRY ) {
+#ifdef __KERNEL__
+		printk(KERN_DEBUG "udf: _fileshortad - 0x%x != TID_FILE_ENTRY\n",
+			fe->descTag.tagIdent);
+#endif
+		return NULL;
+	}
+	lengthShortAds = fe->lengthAllocDescs;
+
+	ptr=(Uint8 *)(fe->extendedAttr);
+	ptr += fe->lengthExtendedAttr;
+
+	if ( (*offset > 0) && (*offset < lengthShortAds) ) {
+		ptr += *offset;
+	}
+	sa = (short_ad *)ptr;
+	*offset = *offset + sizeof(short_ad);
+	return sa;
+}
+
+long_ad *
+udf_get_filelongad(void * buffer, int bufsize, int * offset)
+{
+	long_ad * la;
+	struct FileEntry *fe;
+	int lengthLongAds;
+	Uint8 * ptr;
+
+	if ( (!buffer) || !(offset) ) 
+	{
+#ifdef __KERNEL__
+		printk(KERN_ERR "udf: udf_get_filelongad() invalidparms\n");
+#endif
+		return NULL;
+	}
+
+	fe=(struct FileEntry *)buffer;
+	if ( fe->descTag.tagIdent != TID_FILE_ENTRY ) {
+#ifdef __KERNEL__
+		printk(KERN_DEBUG "udf: _filelongad - 0x%x != TID_FILE_ENTRY\n",
+			fe->descTag.tagIdent);
+#endif
+		return NULL;
+	}
+	lengthLongAds = fe->lengthAllocDescs;
+
+	ptr=(Uint8 *)(fe->extendedAttr);
+	ptr += fe->lengthExtendedAttr;
+
+	if ( (*offset > 0) && (*offset < lengthLongAds) ) {
+		ptr += *offset;
+	}
+	la=(long_ad *)ptr;
+
+	*offset = *offset + sizeof(long_ad);
+	return la;
+}
+
diff -u --recursive --new-file v2.1.129/linux/fs/udf/file.c linux/fs/udf/file.c
--- v2.1.129/linux/fs/udf/file.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/file.c	Sun Nov 29 14:45:28 1998
@@ -0,0 +1,748 @@
+/*
+ * file.c
+ *
+ * PURPOSE
+ *	This file attempts to document the kernel VFS.
+ *
+ * DESCRIPTION
+ *	One day I'll have to write a book on this! :-)
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ *
+ * HISTORY
+ *
+ * 10/2/98 dgb	Attempt to integrate into udf.o
+ * 10/7/98	Switched to using generic_readpage, etc., like isofs
+ *		And it works!
+ */
+
+#ifdef __linux__
+#include <linux/version.h>
+#include <linux/mm.h>
+
+#include <linux/udf_fs.h>
+#endif
+
+#include "udfdecl.h"
+
+typedef void * poll_table; 
+
+/* Prototypes for file operations */
+
+#ifdef CONFIG_UDF_WRITE
+static long udf_write(struct inode *, struct file *, const char *,
+	unsigned long);
+static int udf_fsync(struct file *, struct dentry *);
+static int udf_fasync(struct file *, int);
+static int udf_lock(struct file *, int, struct file_lock *);
+static int udf_revalidate(kdev_t dev);
+static int udf_flush(struct file *);
+#endif
+
+#ifdef CONFIG_UDF_FULL_FS
+static loff_t udf_llseek(struct file *filp, loff_t offset, int origin);
+static ssize_t udf_read(struct file *, char *, size_t, loff_t *);
+static int udf_ioctl(struct inode *, struct file *, unsigned int,
+	unsigned long);
+static int udf_release(struct inode *, struct file *);
+static int udf_open(struct inode *, struct file *);
+
+static unsigned int udf_poll(struct file *, poll_table *);
+static int udf_mmap(struct file *, struct vm_area_struct *);
+static int udf_check_media_change(kdev_t dev);
+#endif
+
+
+struct file_operations udf_file_fops = {
+	NULL,			/* llseek */
+	generic_file_read,	/* read */
+#ifdef CONFIG_UDF_WRITE
+	udf_write,		/* write */
+#else
+	NULL,			/* write */
+#endif
+	NULL,			/* readdir */
+#ifdef CONFIG_UDF_FULL_FS
+	udf_poll,		/* poll */
+	udf_ioctl,		/* ioctl */
+	udf_mmap,		/* mmap */
+	udf_open,		/* open */
+	udf_flush,		/* flush */
+	udf_release,		/* release */
+#else
+	NULL,			/* poll */
+	NULL,			/* ioctl */
+	generic_file_mmap,	/* mmap */
+	NULL,			/* open */
+	NULL,			/* flush */
+	NULL,			/* release */
+#endif
+#ifdef CONFIG_UDF_WRITE
+	udf_fsync,		/* fsync */
+	udf_fasync,		/* fasync */
+	udf_check_media_change,	/* check_media_change */
+	udf_revalidate,		/* revalidate */
+	udf_lock		/* lock */
+#else
+	NULL,			/* fsync */
+	NULL,			/* fasync */
+	NULL,			/* check_media_change */
+	NULL,			/* revalidate */
+	NULL			/* lock */
+#endif
+};
+
+#ifdef USE_UDF_LLSEEK
+/*
+ * udf_llseek
+ *
+ * PURPOSE
+ *	Change the current file position.
+ *
+ * DESCRIPTION
+ *	Optional - the kernel will call default_llseek() if this routine is not
+ *	available.
+ *
+ *	Refer to sys_llseek() in fs/read_write.c
+ *	sys_llseek() -> llseek() -> .
+ *
+ * PRE-CONDITIONS
+ *	filp			Pointer to the file (never NULL).
+ *	offset			Offset to seek (signed!).
+ *	origin			Origin to seek from:
+ *				0 = start, 1 = end, 2 = current
+ *
+ * POST-CONDITIONS
+ *	<retval>		New file position (>=0), or an error code (<0) 
+ *				that sys_llseek() will return.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+loff_t udf_llseek(struct file *filp, loff_t offset, int origin)
+{
+	printk(KERN_ERR "udf: udf_llseek(,%ld, %d)\n",
+		(long)offset, origin);
+	return -1;
+}
+#endif
+
+#ifdef USE_UDF_READ
+/*
+ * udf_read
+ *
+ * PURPOSE
+ *	Read from an open file.
+ *
+ * DESCRIPTION
+ *	Optional - sys_read() will return -EINVAL if this routine is not
+ *	available.
+ *
+ *	Refer to sys_read() in fs/read_write.c
+ *	sys_read() -> .
+ *
+ *	Note that you can use generic_file_read() instead, which requires that
+ *	udf_readpage() be available, but you can use generic_readpage(), which
+ *	requires that udf_bmap() be available. Reading will then be done by
+ *	memory-mapping the file a page at a time. This is not suitable for
+ *	devices that don't handle read-ahead [example: CD-R/RW that may have
+ *	blank sectors that shouldn't be read].
+ *
+ *	Refer to generic_file_read() in mm/filemap.c and to generic_readpage()
+ *	in fs/buffer.c
+ *
+ *	Block devices can use block_read() instead. Refer to fs/block_dev.c
+ *
+ * PRE-CONDITIONS
+ *	inode			Pointer to inode to read from (never NULL).
+ *	filp			Pointer to file to read from (never NULL).
+ *	buf			Point to read buffer (validated).
+ *	bufsize			Size of read buffer.
+ *
+ * POST-CONDITIONS
+ *	<return>		Bytes read (>=0) or an error code (<0) that
+ *				sys_read() will return.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static ssize_t udf_read(struct file * filp, char * buf, size_t bufsize, 
+	loff_t * loff)
+{
+	printk(KERN_ERR "udf: udf_read(,,%ld, %ld)\n",
+		(long)bufsize, (long)loff);
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_write
+ *
+ * PURPOSE
+ *	Write to an open file.
+ *
+ * DESCRIPTION
+ *	Optional - sys_write() will return -EINVAL if this routine is not
+ *	available.
+ *
+ *	Refer to sys_write() in fs/read_write.c
+ *	sys_write() -> .
+ *
+ *	Block devices can use block_write() instead. Refer to fs/block_dev.c
+ *
+ * PRE-CONDITIONS
+ *	inode			Pointer to inode to write to (never NULL).
+ *	filep			Pointer to file to write to (Never NULL).
+ *	buf			Pointer to write buffer (validated).
+ *	bufsize			Size of write buffer.
+ *
+ * POST-CONDITIONS
+ *	<return>		Bytes written (>=0) or an error code (<0) that
+ *				sys_write() will return.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+long udf_write(struct inode *inode, struct file *filp, const char *buf,
+	unsigned long bufsize)
+{
+	return -1;
+}
+#endif
+
+
+#ifdef CONFIG_UDF_FULL_FS
+/*?
+ * udf_poll
+ *
+ * PURPOSE
+ *	Poll file(s).
+ *
+ * DESCRIPTION
+ *	Optional - sys_poll() uses DEFAULT_POLLMASK if this routine is not
+ *	available.
+ *
+ *	Refer to sys_poll() in fs/select.c
+ *	sys_poll() -> do_poll() -> .
+ *
+ * PRE-CONDITIONS
+ *	filp			Pointer to file to poll.
+ *	table			Pointer to poll table.
+ *
+ * POST-CONDITIONS
+ *	<return>		Poll mask.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+unsigned int udf_poll(struct file *filp, poll_table *table)
+{
+	return -1;
+}
+#endif
+
+/*
+ * udf_ioctl
+ *
+ * PURPOSE
+ *	Issue an ioctl.
+ *
+ * DESCRIPTION
+ *	Optional - sys_ioctl() will return -ENOTTY if this routine is not
+ *	available, and the ioctl cannot be handled without filesystem help.
+ *
+ *	sys_ioctl() handles these ioctls that apply only to regular files:
+ *		FIBMAP [requires udf_bmap()], FIGETBSZ, FIONREAD
+ *	These ioctls are also handled by sys_ioctl():
+ *		FIOCLEX, FIONCLEX, FIONBIO, FIOASYNC
+ *	All other ioctls are passed to the filesystem.
+ *
+ *	Refer to sys_ioctl() in fs/ioctl.c
+ *	sys_ioctl() -> .
+ *
+ * PRE-CONDITIONS
+ *	inode			Pointer to inode that ioctl was issued on.
+ *	filp			Pointer to file that ioctl was issued on.
+ *	cmd			The ioctl command.
+ *	arg			The ioctl argument [can be interpreted as a
+ *				user-space pointer if desired].
+ *
+ * POST-CONDITIONS
+ *	<return>		Success (>=0) or an error code (<=0) that
+ *				sys_ioctl() will return.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
+	unsigned long arg)
+{
+	printk(KERN_ERR "udf: udf_ioctl(ino %lu,, %d,)\n",
+		inode->i_ino, cmd);
+	return -1;
+}
+
+#ifdef CONFIG_UDF_FULL_FS
+/*
+ * udf_mmap
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_mmap(struct file *filp, struct vm_area_struct *)
+{
+	return -1;
+}
+
+/*
+ * udf_open
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_open(struct inode *inode, struct file *filp)
+{
+	printk(KERN_ERR "udf: udf_open(ino %lu,)\n",
+		inode->i_ino);
+	return -1;
+}
+
+/*
+ * udf_release
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_release(struct inode *inode, struct file *filp)
+{
+	printk(KERN_ERR "udf: udf_release(ino %lu,)\n",
+		inode->i_ino);
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_fsync
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_fsync(struct file *filp, struct dentry *)
+{
+	return -1;
+}
+
+/*
+ * udf_fasync
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_fasync(struct file *filp, int)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_FULL_FS
+/*
+ * udf_check_media_change
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_check_media_change(kdev_t dev)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_revalidate
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_revalidate(kdev_t dev)
+{
+	return -1;
+}
+
+/*
+ * udf_lock
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_lock(struct file *filp, int, struct file_lock *)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+static int udf_create(struct inode *, struct dentry *, int);
+static int udf_link(struct inode *, struct inode *, struct dentry *);
+static int udf_unlink(struct inode *, struct dentry *);
+static int udf_symlink(struct inode *, struct dentry *, const char *);
+static int udf_mkdir(struct inode *, struct dentry *, int);
+static int udf_rmdir(struct inode *, struct dentry *);
+static int udf_mknod(struct inode *, struct dentry *, ints, int);
+static int udf_rename(struct inode *, struct dentry *, struct inode *,
+	struct dentry *);
+static int udf_writepage(struct inode *, struct page *);
+static void udf_truncate(struct inode *);
+static int udf_updatepage(struct inode *, struct page *, const char *,
+	unsigned long, unsigned int, int);
+static int udf_revalidate(struct inode *);
+#endif
+
+#ifdef CONFIG_UDF_FULL_FS
+static int udf_readlink(struct inode *, char *, int);
+static struct dentry * udf_follow_link(struct inode *, struct dentry *);
+static int udf_readpage(struct inode *, struct page *);
+static int udf_permission(struct inode *, int);
+static int udf_smap(struct inode *, int);
+#endif
+
+
+struct inode_operations udf_file_inode_operations= {
+	&udf_file_fops,
+#ifdef CONFIG_UDF_WRITE
+	udf_create,		/* create */
+	udf_lookup,		/* lookup */
+	udf_link,		/* link */
+	udf_unlink,		/* unlink */
+	udf_symlink,		/* symlink */
+	udf_mkdir,		/* mkdir */
+	udf_rmdir,		/* rmdir */
+	udf_mknod,		/* mknod */
+	udf_rename,		/* rename */
+	udf_readlink,		/* readlink */
+	udf_follow_link,	/* follow_link */
+	udf_readpage,		/* readpage */
+	udf_writepage,		/* writepage */
+	udf_bmap,		/* bmap */
+	udf_truncate,		/* truncate */
+	udf_permission,		/* permission */
+	udf_smap,		/* smap */
+	udf_updatepage,		/* updatepage */
+	udf_revalidate		/* revalidate */
+#else
+	NULL,			/* create */
+	udf_lookup,		/* lookup */
+	NULL,			/* link */
+	NULL,			/* unlink */
+	NULL,			/* symlink */
+	NULL,			/* mkdir */
+	NULL,			/* rmdir */
+	NULL,			/* mknod */
+	NULL,			/* rename */
+	NULL,			/* readlink */
+	NULL,			/* follow_link */
+#ifdef CONFIG_UDF_FULL_FS
+	udf_readpage,		/* readpage */
+#else
+	generic_readpage,	/* readpage */
+#endif
+	NULL,			/* writepage */
+	udf_bmap,		/* bmap */
+	NULL,			/* truncate */
+#ifdef CONFIG_UDF_FULL_FS
+	udf_permission,		/* permission */
+#else
+	NULL,
+#endif
+	NULL,			/* smap */
+	NULL,			/* updatepage */
+	NULL			/* revalidate */
+#endif
+};
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_create
+ *
+ * PURPOSE
+ *	Create an inode.
+ *
+ * DESCRIPTION
+ *	Optional - sys_open() will return -EACCESS if not available.
+ *
+ *	This routine is passed an incomplete dentry - it doesn't have an
+ *	assigned inode, so one must be assigned by calling:
+ *		d_instantiate(dentry, inode)
+ *
+ *	Refer to sys_open() in fs/open.c and open_namei() in fs/namei.c
+ *	sys_open() -> do_open() -> open_namei() -> .
+ *
+ * PRE-CONDITIONS
+ *	dir			Pointer to inode of parent directory.
+ *	dentry			Pointer to dentry to complete.
+ *	mode			Mode of new inode.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_create(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_readpage
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *	Used for memory mapping. See generic_readpage() in fs/buffer.c for
+ *	filesystems that support the bmap() operation.
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_readpage(struct inode *inode, struct page *)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_writepage
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *	Used for memory mapping. Required if readpage() is defined.
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_writepage(struct inode *inode, struct page *)
+{
+	return -1;
+}
+
+/*
+ * udf_truncate
+ *
+ * PURPOSE
+ *	Truncate a file.
+ *
+ * DESCRIPTION
+ *	This routine is called by sys_truncate() to reduce the size of a file.
+ *
+ * PRE-CONDITIONS
+ *	inode			Pointer to inode of file to truncate.
+ *
+ * POST-CONDITIONS
+ *	None.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static void
+udf_truncate(struct inode *inode)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_FULL_FS
+/*
+ * udf_permissions
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_permission(struct inode *inode, int)
+{
+	return -1;
+}
+
+/*
+ * udf_smap
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_smap(struct inode *inode, int)
+{
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_UDF_WRITE
+/*
+ * udf_updatepage
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_updatepage(struct inode *inode, struct page *, const char *, unsigned long, unsigned int, int)
+{
+	return -1;
+}
+
+/*
+ *
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *
+ * PRE-CONDITIONS
+ *
+ * POST-CONDITIONS
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_revalidate(struct inode *inode)
+{
+	return -1;
+}
+#endif
diff -u --recursive --new-file v2.1.129/linux/fs/udf/inode.c linux/fs/udf/inode.c
--- v2.1.129/linux/fs/udf/inode.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/inode.c	Sun Nov 29 14:45:28 1998
@@ -0,0 +1,518 @@
+/*
+ * inode.c
+ *
+ * PURPOSE
+ *	Inode handling routines for the OSTA-UDF(tm) filesystem.
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ *
+ * HISTORY
+ *
+ * 10/4/98 dgb	Added rudimentary directory functions
+ * 10/7/98	Fully working udf_bmap! It works!
+ * 11/25/98	bmap altered to better support extents
+ *
+ */
+
+#include <linux/udf_fs.h>
+
+#include "udfdecl.h"
+
+/*
+ * udf_read_inode
+ *
+ * PURPOSE
+ *	Read an inode.
+ *
+ * DESCRIPTION
+ *	This routine is called by iget() [replaced by udf_iget()]
+ *	when an inode is first read into memory.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+void
+udf_read_inode(struct inode *inode)
+{
+	struct buffer_head *bh;
+	struct FileEntry *fe;
+	time_t modtime, acctime;
+	int block;
+	int offset;
+
+#ifdef VDEBUG
+	printk(KERN_DEBUG "udf_read_inode: inode=0x%lx\n", (unsigned long)inode);
+#endif
+
+	UDF_I_FILELENHIGH(inode)=0;
+	UDF_I_FILELENLOW(inode)=0;
+	UDF_I_EXT0LEN(inode)=0;
+	UDF_I_EXT0LOC(inode)=0;
+	UDF_I_EXT0OFFS(inode)=0;
+	UDF_I_DIRPOS(inode)=0;
+	UDF_I_ALLOCTYPE(inode)=0;
+
+	block=udf_block_from_inode(inode->i_sb, inode->i_ino);
+	bh=udf_read_tagged(inode->i_sb, block, UDF_BLOCK_OFFSET(inode->i_sb));
+	if ( !bh ) {
+		printk(KERN_ERR "udf: udf_read_inode(ino %ld) block %d failed !bh\n",
+			inode->i_ino, block);
+		return;
+	}
+
+	fe=(struct FileEntry *)bh->b_data;
+	if ( fe->descTag.tagIdent == TID_FILE_ENTRY) {
+		UDF_I_FILELENHIGH(inode)=udf64_high32(fe->informationLength);
+		UDF_I_FILELENLOW(inode)=udf64_low32(fe->informationLength);
+
+#ifdef DEBUG
+		printk(KERN_DEBUG
+	"udf: block: %u ino %ld FILE_ENTRY: len %u,%u blocks %u perm 0x%x link %d type 0x%x flags 0x%x\n",
+			block, inode->i_ino, 
+			UDF_I_FILELENHIGH(inode),
+			UDF_I_FILELENLOW(inode),
+			udf64_low32(fe->logicalBlocksRecorded), /* may be zero! */
+			fe->permissions, 
+			fe->fileLinkCount, 
+			fe->icbTag.fileType, fe->icbTag.flags);
+#endif
+
+		inode->i_uid = udf_convert_uid(fe->uid);
+		if ( !inode->i_uid ) inode->i_uid = UDF_SB(inode->i_sb)->s_uid;
+
+		inode->i_gid = udf_convert_gid(fe->gid);
+		if ( !inode->i_gid ) inode->i_gid = UDF_SB(inode->i_sb)->s_gid;
+
+		inode->i_nlink = fe->fileLinkCount;
+		inode->i_size = UDF_I_FILELENLOW(inode);
+
+		if ( udf_stamp_to_time(&modtime, &fe->modificationTime) ) {
+			inode->i_mtime = modtime;
+			inode->i_ctime = modtime;
+		} else {
+			inode->i_mtime = UDF_SB_RECORDTIME(inode->i_sb);
+			inode->i_ctime = UDF_SB_RECORDTIME(inode->i_sb);
+		}
+		if ( udf_stamp_to_time(&acctime, &fe->accessTime) ) 
+			inode->i_atime = acctime;
+		else
+			inode->i_atime = UDF_SB_RECORDTIME(inode->i_sb);
+
+		UDF_I_ALLOCTYPE(inode)=fe->icbTag.flags & ICB_FLAG_ALLOC_MASK;
+		switch (UDF_I_ALLOCTYPE(inode)) {
+			case ICB_FLAG_AD_SHORT:
+ 			  {
+ 			    short_ad * sa;
+ 
+ 			    offset=0;
+ 			    sa=udf_get_fileshortad(fe, 
+				inode->i_sb->s_blocksize, &offset);
+ 			    if ( (sa) && (sa->extLength & 0x3FFFFFFF) ) {
+ 				UDF_I_EXT0LEN(inode)=sa->extLength & 0x3FFFFFFF;
+ 				UDF_I_EXT0LOC(inode)=sa->extPosition;
+ 			    }
+ #ifdef DEBUG
+ 			    printk(KERN_DEBUG
+ 				"udf: ino %lu (AD_SHORT) len %u lblock %u pblock %u\n",
+ 				inode->i_ino,
+ 				UDF_I_EXT0LEN(inode),
+ 				UDF_I_EXT0LOC(inode),
+ 				sa->extPosition+
+ 				  UDF_BLOCK_OFFSET(inode->i_sb));
+ #endif
+ 			  }
+			  break;
+			case ICB_FLAG_AD_LONG:
+			  {
+			    long_ad * la;
+			    int ext=0;
+
+			    offset=0;
+			    la=udf_get_filelongad(fe, inode->i_sb->s_blocksize, &offset);
+			    if ( (la) && (la->extLength) ) {
+				UDF_I_EXT0LEN(inode)=la->extLength;
+				UDF_I_EXT0LOC(inode)=la->extLocation.logicalBlockNum;
+#ifdef VDEBUG
+				printk(KERN_DEBUG
+				   "udf: ino %lu AD_LONG ext[0]-> %u len %u\n",
+				   inode->i_ino,
+				   UDF_I_EXT0LOC(inode),
+				   UDF_I_EXT0LEN(inode));
+#endif
+			        la=udf_get_filelongad(fe, inode->i_sb->s_blocksize, &offset);
+#ifdef DEBUG
+				while ( (la) &&
+				    (la->extLength) &&
+				    (offset < fe->lengthAllocDescs)) {
+					printk(KERN_DEBUG
+					   "udf: ino %lu AD_LONG ext[%u]-> %u len %u\n",
+						inode->i_ino,
+						++ext, 
+						la->extLocation.logicalBlockNum,
+						la->extLength);
+			        	la=udf_get_filelongad(fe, inode->i_sb->s_blocksize, 
+								&offset);
+				}
+#endif
+			    } 
+			  }
+			  break;
+			case ICB_FLAG_AD_EXTENDED:
+			  {
+			    extent_ad * ext;
+			    offset=0;
+			    ext=udf_get_fileextent(fe, inode->i_sb->s_blocksize, &offset);
+			    if ( (ext) && (ext->extLength) ) {
+				UDF_I_EXT0LEN(inode)=ext->extLength;
+				UDF_I_EXT0LOC(inode)=ext->extLocation;
+			        while (offset < fe->lengthAllocDescs) {
+#ifdef VDEBUG
+				   printk(KERN_DEBUG
+				      "udf: ino %lu AD_EXT ext[0]-> %u len %u\n",
+				      inode->i_ino,
+					  ext->extLocation,
+					  ext->extLength);
+#endif
+			    		ext=udf_get_fileextent(fe, inode->i_sb->s_blocksize, &offset);
+				}
+			    }
+			  }
+			  break;
+			case ICB_FLAG_AD_IN_ICB: /* short directories */
+#ifdef VDEBUG
+			  printk(KERN_DEBUG "udf: ino %lu (AD_IN_ICB) len %u\n",
+					  inode->i_ino, fe->lengthAllocDescs);
+#endif
+			  UDF_I_EXT0LEN(inode)=fe->lengthAllocDescs;
+			  UDF_I_EXT0LOC(inode)=inode->i_ino;
+			  UDF_I_EXT0OFFS(inode)= (int)fe->extendedAttr - (int)fe +
+						fe->lengthExtendedAttr;
+			  break;
+		} /* end switch ad_type */
+
+		switch (fe->icbTag.fileType) {
+		case FILE_TYPE_DIRECTORY:
+#ifdef VDEBUG
+			printk(KERN_DEBUG "udf: ino %lu directory %u len %u loc %u offs %u\n",
+				inode->i_ino,
+				UDF_I_ALLOCTYPE(inode), UDF_I_EXT0LEN(inode), 
+				UDF_I_EXT0LOC(inode), UDF_I_EXT0OFFS(inode));
+#endif
+			inode->i_op = &udf_dir_inode_operations;
+			inode->i_mode = S_IFDIR|(fe->permissions & 00007)|((fe->permissions >> 2) & 00070)|((fe->permissions >> 4) & 00700);
+			break;
+		case FILE_TYPE_REGULAR:
+		case FILE_TYPE_NONE:
+			inode->i_op = &udf_file_inode_operations;
+			inode->i_mode = S_IFREG|(fe->permissions & 00007)|((fe->permissions >> 2) & 00070)|((fe->permissions >> 4) & 00700);
+			break;
+		case FILE_TYPE_SYMLINK:
+			/* untested! */
+#ifdef VDEBUG
+			printk(KERN_DEBUG "udf: ino %lu symlink %u\n",
+				inode->i_ino,
+				UDF_I_ALLOCTYPE(inode));
+#endif
+			inode->i_op = &udf_file_inode_operations;
+			inode->i_mode = S_IFLNK|(fe->permissions & 00007)|((fe->permissions >> 2) & 00070)|((fe->permissions >> 4) & 00700);
+			break;
+		}
+	} else {
+		printk(KERN_ERR "udf: ino %lu is tag 0x%x, not FILE_ENTRY\n",
+			inode->i_ino, ((tag *)bh->b_data)->tagIdent );
+	}
+	udf_release_data(bh);
+}
+
+/*
+ * udf_write_inode
+ *
+ * PURPOSE
+ *	Write out the specified inode.
+ *
+ * DESCRIPTION
+ *	This routine is called whenever an inode is synced.
+ *	Currently this routine is just a placeholder.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+void
+udf_write_inode(struct inode *inode)
+{
+	COOKIE(("udf_write_inode: inode=0x%lx\n", (unsigned long)inode));
+}
+
+/*
+ * udf_put_inode
+ *
+ * PURPOSE
+ *
+ * DESCRIPTION
+ *	This routine is called whenever the kernel no longer needs the inode.
+ *	Currently this routine is just a placeholder.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+void
+udf_put_inode(struct inode *inode)
+{
+	COOKIE(("udf_put_inode: inode=0x%lx\n", (unsigned long)inode));
+
+	/* Delete unused inodes */
+	if (inode && inode->i_count == 1)
+		inode->i_nlink = 0;
+}
+
+/*
+ * udf_delete_inode
+ *
+ * PURPOSE
+ *	Clean-up before the specified inode is destroyed.
+ *
+ * DESCRIPTION
+ *	This routine is called when the kernel destroys an inode structure
+ *	ie. when iput() finds i_count == 0.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+void
+udf_delete_inode(struct inode *inode)
+{
+	COOKIE(("udf_delete_inode: inode=0x%lx\n", (unsigned long)inode));
+	inode->i_size = 0;
+	clear_inode(inode);
+}
+
+/*
+ * udf_iget
+ *
+ * PURPOSE
+ *	Get an inode.
+ *
+ * DESCRIPTION
+ *	This routine replaces iget() and read_inode().
+ *
+ * HISTORY
+ *	October 3, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+struct inode *
+udf_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "udf_iget: ino=0x%lx\n", ino);
+#endif
+
+	/* Get the inode */
+	inode = iget(sb, ino);
+	if (!inode) {
+		printk(KERN_ERR "udf: iget() failed\n");
+		return NULL;
+	}
+
+	if ( ino >= UDF_SB_PARTLEN(sb) ) {
+		printk(KERN_ERR "udf: iget(,%ld) out of range\n",
+			ino);
+		return NULL;
+ 	}
+
+	/* Cached inode - nothing to do */
+	if (inode->i_op && inode->i_nlink)
+		return inode;
+
+	/* Sanity check */
+	if (inode->i_op) {
+		printk(KERN_WARNING "udf: i_op != NULL\n");
+		inode->i_op = NULL;
+	}
+#ifdef VDEBUG	
+	if (inode->i_nlink)
+		printk(KERN_DEBUG "udf: i_nlink != 0, %d\n",
+			inode->i_nlink);
+#endif
+
+	/*
+	 * Set defaults, but the inode is still incomplete!
+	 * Note: iget() sets the following on a new inode:
+	 *	i_sb = sb
+	 *	i_dev = sb->s_dev;
+	 *	i_no = ino
+	 *	i_flags = sb->s_flags
+	 *	i_count = 1
+	 *	i_state = 0
+	 * and udf_read_inode() sets these:
+	 *	(!)i_op = NULL
+	 *	i_nlink = 0
+	 */
+	inode->i_blksize = sb->s_blocksize;
+	inode->i_mode = UDF_SB(sb)->s_mode;
+	inode->i_gid = UDF_SB(sb)->s_gid;
+	inode->i_uid = UDF_SB(sb)->s_uid;
+
+	/* Mark the inode as empty */
+	inode->i_op = NULL; 
+	inode->i_nlink = 0; 
+
+	inode->i_version = 1;
+
+	udf_read_inode(inode);
+
+	return inode;
+}
+
+/*
+ * given an inode and block ...
+ */
+int 
+udf_bmap(struct inode * inode,int block)
+{
+	off_t b_off, size, bsize;
+	unsigned int firstext;
+	int result=0;
+	int blocksize;
+	int offset;
+
+	if (block<0) {
+		printk(KERN_ERR "udf: udf_bmap: block<0\n");
+		return 0;
+	}
+
+	if (!inode) {
+		printk(KERN_ERR "udf: udf_bmap: NULL inode\n");
+		return 0;
+	}
+
+	blocksize=inode->i_sb->s_blocksize;
+	b_off = block << inode->i_sb->s_blocksize_bits;
+
+	/*
+	 * If we are beyond the end of this file, don't give out any
+	 * blocks.
+	 */
+	if( b_off > inode->i_size ) {
+	    off_t	max_legal_read_offset;
+
+	    /*
+	     * If we are *way* beyond the end of the file, print a message.
+	     * Access beyond the end of the file up to the next page boundary
+	     * is normal, however because of the way the page cache works.
+	     * In this case, we just return 0 so that we can properly fill
+	     * the page with useless information without generating any
+	     * I/O errors.
+	     */
+	    max_legal_read_offset = (inode->i_size + PAGE_SIZE - 1)
+	      & ~(PAGE_SIZE - 1);
+	    if( b_off >= max_legal_read_offset ) {
+		printk(KERN_ERR "udf: udf_bmap: block>= EOF(%d, %ld)\n", block,
+		       inode->i_size);
+	    }
+	    return 0;
+	}
+
+	/* check for first extent case, so we don't need to reread FileEntry */
+	offset = 0;
+	firstext = UDF_I_EXT0LOC(inode) + UDF_BLOCK_OFFSET(inode->i_sb);
+	bsize = UDF_I_EXT0LEN(inode);
+	size = UDF_I_EXT0LEN(inode) >> inode->i_sb->s_blocksize_bits; /* in blocks */
+	if ( (UDF_I_EXT0LEN(inode) % blocksize) > 0 )
+		size++;
+
+	if ( block < size ) {
+	   result= firstext + block;
+	} else {
+	   /* Bad news:
+	    * we'll have to do this the long way 
+	    */
+	   struct buffer_head *bh;
+	   int dirblock;
+	   struct FileEntry *fe;
+
+	   dirblock=udf_block_from_inode(inode->i_sb, inode->i_ino);
+	   bh=udf_read_tagged(inode->i_sb, dirblock, 
+			UDF_BLOCK_OFFSET(inode->i_sb));
+	   if ( !bh ) {
+		printk(KERN_ERR 
+			"udf: udf_read_inode(ino %ld) block %d failed !bh\n",
+			inode->i_ino, dirblock);
+		return 0;
+	   }
+
+	   fe=(struct FileEntry *)bh->b_data;
+	   switch (UDF_I_ALLOCTYPE(inode)) {
+		case ICB_FLAG_AD_SHORT:
+		{
+			short_ad * sa;
+			offset = sizeof(short_ad);
+			do
+			{
+				b_off -= bsize;
+				sa=udf_get_fileshortad(fe, blocksize, &offset);
+				bsize = sa->extLength & UDF_EXTENT_LENGTH_MASK;
+#ifdef VDEBUG
+				printk(KERN_DEBUG "udf: offset: %u len: %u pos: %u 0len: %u b_off %lu bsize %lu\n",
+					offset, sa->extLength,
+					sa->extPosition, UDF_I_EXT0LEN(inode),
+					b_off, bsize);
+#endif
+			} while ( (sa) && 
+				(sa->extLength & UDF_EXTENT_LENGTH_MASK) &&
+				(offset < UDF_I_EXT0LEN(inode)) &&
+				(b_off >= bsize) );
+			firstext = sa->extPosition + 
+				UDF_BLOCK_OFFSET(inode->i_sb);
+			break;
+		}
+		case ICB_FLAG_AD_LONG:
+		{
+			long_ad * la;
+			int extblock=0;
+			int offset=0;
+			int ext=0;
+
+			la=udf_get_filelongad(fe, blocksize, &offset);
+			/* loop through all the extents until we get there */
+			while ( (la) && (!result) ) {
+			    if ( la->extLength ) {
+				extblock += la->extLength/blocksize;
+				if ( (la->extLength % blocksize) )
+					extblock++;
+				if ( extblock >= block ) {
+				   result=la->extLocation.logicalBlockNum;
+				   result += extblock - block;
+				   printk(KERN_DEBUG
+				 	"udf: ino %lu lblock %u in ext %u, block %u\n",
+					inode->i_ino, block, ext, result);
+				   continue;
+				}
+			    }
+			    ext++;
+			    /* read next extent */
+			    if (offset < fe->lengthAllocDescs) {
+			        la=udf_get_filelongad(fe, blocksize, &offset);
+			    } 
+			} /* end while */
+		}
+		break;
+	   } /* end switch */
+	}
+	return result;
+}
+
diff -u --recursive --new-file v2.1.129/linux/fs/udf/misc.c linux/fs/udf/misc.c
--- v2.1.129/linux/fs/udf/misc.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/misc.c	Sun Nov 29 14:45:28 1998
@@ -0,0 +1,314 @@
+/*
+ * misc.c
+ *
+ * PURPOSE
+ *	Miscellaneous routines for the OSTA-UDF(tm) filesystem.
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ */
+
+
+#if defined(__linux__) && defined(__KERNEL__)
+
+#include <linux/fs.h>
+#include <linux/udf_fs.h>
+
+#else
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <linux/udf_fs.h>
+
+int udf_blocksize=0;
+int udf_errno=0;
+
+void 
+udf_setblocksize(int size)
+{
+	udf_blocksize=size;
+}
+#endif
+
+Uint32
+udf64_low32(Uint64 indat)
+{
+	Uint32 * uptr;
+	uptr=(Uint32 *)&indat;
+	return uptr[0];
+}
+
+Uint32
+udf64_high32(Uint64 indat)
+{
+	Uint32 * uptr;
+	uptr=(Uint32 *)&indat;
+	return uptr[1];
+}
+
+/*
+ * udf_stamp_to_time
+ */
+time_t * 
+udf_stamp_to_time(time_t *dest, void * srcp)
+{
+	timestamp *src;
+	struct ktm tm;
+
+	if ((!dest) || (!srcp) )
+	    return NULL;
+	src=(timestamp *)srcp;
+
+	/* this is very rough. need to find source to mktime() */
+	tm.tm_year=(src->year) - 1900;	
+	tm.tm_mon=(src->month);
+	tm.tm_mday=(src->day);
+	tm.tm_hour=src->hour;
+	tm.tm_min=src->minute;
+	tm.tm_sec=src->second;
+	*dest = udf_converttime(&tm);
+	return dest;
+}
+
+uid_t udf_convert_uid(int uidin)
+{
+    if ( uidin == -1 )
+	return 0;
+    if ( uidin > (64*1024U - 1) )
+	return 0;
+    return uidin;
+}
+
+gid_t udf_convert_gid(int gidin)
+{
+    if ( gidin == -1 )
+	return 0;
+    if ( gidin > (64*1024U - 1) )
+	return 0;
+    return gidin;
+}
+
+#if defined(__linux__) && defined(__KERNEL__)
+extern struct buffer_head *
+udf_read_untagged(struct super_block *sb, Uint32 block, Uint32 offset)
+{
+	struct buffer_head *bh;
+
+	/* Read the block */
+	bh = bread(sb->s_dev, block+offset, sb->s_blocksize);
+	if (!bh) {
+		printk(KERN_ERR "udf: udf_read_untagged(,%d) failed\n",
+			block);
+		return NULL;
+	}
+	return bh;
+}
+
+/*
+ * udf_read_tagged
+ *
+ * PURPOSE
+ *	Read the first block of a tagged descriptor.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+extern struct buffer_head *
+udf_read_tagged(struct super_block *sb, Uint32 block, Uint32 offset)
+{
+	tag *tag_p;
+	struct buffer_head *bh;
+	register Uint8 checksum;
+	register int i;
+
+	/* Read the block */
+	bh = bread(sb->s_dev, block, sb->s_blocksize);
+	if (!bh) {
+		printk(KERN_ERR "udf: udf_read_tagged(,%d) failed\n",
+			block);
+		return NULL;
+	}
+
+	tag_p = (tag *)(bh->b_data);
+
+	/* Verify the tag location */
+	if ( ((block-offset) != tag_p->tagLocation) &&
+	     (block != tag_p->tagLocation) ) {
+		static int seen_msg=0;
+
+		if (!seen_msg) {	
+			printk(KERN_DEBUG "udf: location mismatch block %d, offset %d, tag %d\n",
+				block, offset, tag_p->tagLocation);
+			seen_msg=1;
+		}
+		/*
+		goto error_out;
+		*/
+	}
+	
+	/* Verify the tag checksum */
+	checksum = 0U;
+	for (i = 0; i < 4; i++)
+		checksum += (Uint8)(bh->b_data[i]);
+	for (i = 5; i < 16; i++)
+		checksum += (Uint8)(bh->b_data[i]);
+	if (checksum != tag_p->tagChecksum) {
+		printk(KERN_ERR "udf: tag checksum failed\n");
+		goto error_out;
+	}
+
+#ifdef USE_STRICT_VERSION
+	/* Verify the tag version */
+	if (tag_p->descVersion != 0x0002U) {
+		printk(KERN_ERR "udf: tag version 0x%04x != 0x0002U\n",
+			tag_p->descVersion);
+		goto error_out;
+	}
+#endif
+
+	/* Verify the descriptor CRC */
+	if (tag_p->descCRC == udf_crc(bh->b_data + 16, tag_p->descCRCLength)) {
+		return bh;
+	}
+	printk(KERN_ERR "udf: crc failure in udf_read_tagged\n");
+
+error_out:
+	brelse(bh);
+	return NULL;
+}
+
+void
+udf_release_data(struct buffer_head *bh)
+{
+	if (bh)
+		brelse(bh);
+}
+
+#endif
+
+#ifndef __KERNEL__
+/*
+ * udf_read_tagged_data
+ *
+ * PURPOSE
+ *	Read the first block of a tagged descriptor.
+ *	Usable from user-land.
+ *
+ * HISTORY
+ *      10/4/98 dgb: written
+ */
+int
+udf_read_tagged_data(char *buffer, int size, int fd, int block, int offset)
+{
+	tag *tag_p;
+	register Uint8 checksum;
+	register int i;
+	unsigned long offs;
+
+	if (!buffer) {
+		udf_errno=1;
+		return -1;
+	}
+
+	if ( !udf_blocksize ) {
+		udf_errno=2;
+		return -1;
+	}
+
+	if ( size < udf_blocksize ) {
+		udf_errno=3;
+		return -1;
+	}
+	udf_errno=0;
+	
+	offs=(long)block * udf_blocksize;
+	if ( lseek(fd, offs, SEEK_SET) != offs ) {
+		udf_errno=4;
+		return -1;
+	}
+
+	i=read(fd, buffer, udf_blocksize);
+	if ( i < udf_blocksize ) {
+		udf_errno=5;
+		return -1;
+	}
+
+	tag_p = (tag *)(buffer);
+
+	/* Verify the tag location */
+	if ((block-offset) != tag_p->tagLocation) {
+#ifdef __KERNEL__
+		printk(KERN_ERR "udf: location mismatch block %d, tag %d\n",
+			block, tag_p->tagLocation);
+#else
+		udf_errno=6;
+#endif
+		goto error_out;
+	}
+	
+	/* Verify the tag checksum */
+	checksum = 0U;
+	for (i = 0; i < 4; i++)
+		checksum += (Uint8)(buffer[i]);
+	for (i = 5; i < 16; i++)
+		checksum += (Uint8)(buffer[i]);
+	if (checksum != tag_p->tagChecksum) {
+#ifdef __KERNEL__
+		printk(KERN_ERR "udf: tag checksum failed\n");
+#else
+		udf_errno=7;
+#endif
+		goto error_out;
+	}
+
+	/* Verify the tag version */
+	if (tag_p->descVersion != 0x0002U) {
+#ifdef __KERNEL__
+		printk(KERN_ERR "udf: tag version 0x%04x != 0x0002U\n",
+			tag_p->descVersion);
+#else
+		udf_errno=8;
+#endif
+		goto error_out;
+	}
+
+	/* Verify the descriptor CRC */
+	if (tag_p->descCRC == udf_crc(buffer + 16, tag_p->descCRCLength)) {
+		udf_errno=0;
+		return 0;
+	}
+#ifdef __KERNEL__
+	printk(KERN_ERR "udf: crc failure in udf_read_tagged\n");
+#else
+	udf_errno=9;
+#endif
+
+error_out:
+	return -1;
+}
+#endif
+
+#ifdef __KERNEL__
+long
+udf_block_from_inode(struct super_block *sb, long ino)
+{
+	return ino + UDF_BLOCK_OFFSET(sb);
+}
+
+long
+udf_inode_from_block(struct super_block *sb, long block)
+{
+	return block - UDF_BLOCK_OFFSET(sb);
+}
+#endif
+
diff -u --recursive --new-file v2.1.129/linux/fs/udf/super.c linux/fs/udf/super.c
--- v2.1.129/linux/fs/udf/super.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/super.c	Sun Nov 29 17:12:20 1998
@@ -0,0 +1,1307 @@
+/*
+ * super.c
+ *
+ * CHANGES
+ * 9/24/98 dgb:	changed to allow compiling outside of kernel, and
+ *		added some debugging.
+ * 10/1/98 dgb: updated to allow (some) possibility of compiling w/2.0.34
+ * 10/16/98	attempting some multi-session support
+ * 10/17/98	added freespace count for "df"
+ * 11/11/98 gr: added novrs option
+ * 11/26/98 dgb added fileset,anchor mount options
+ *
+ * PURPOSE
+ *	Super block routines for UDF filesystem.
+ *
+ * DESCRIPTION
+ *	OSTA-UDF(tm) = Optical Storage Technology Association
+ *	Universal Disk Format.
+ *
+ *	This code is based on version 1.50 of the UDF specification,
+ *	and revision 2 of the ECMA 167 standard [equivalent to ISO 13346].
+ *	http://www.osta.org/	http://www.ecma.ch/	http://www.iso.org/
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ */
+
+#ifndef LINUX_VERSION_CODE
+#include <linux/version.h>
+#endif
+
+#include <linux/blkdev.h>
+#include <linux/fs.h>
+#include <linux/malloc.h>
+#include <linux/kernel.h>
+#include <linux/locks.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+#include <linux/cdrom.h>
+#include <asm/byteorder.h>
+
+#if LINUX_VERSION_CODE > 0x020170
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#else
+#define NEED_COPY_TO_USER
+#define NEED_GET_HARDBLOCKSIZE
+#define NEED_LE32_TO_CPU
+#endif
+
+#include <linux/udf_fs.h>
+#include "udfdecl.h"
+
+/* These are the "meat" - everything else is stuffing */
+static struct super_block *udf_read_super(struct super_block *, void *, int);
+static void udf_put_super(struct super_block *);
+static int udf_check_valid(struct super_block *sb, int);
+static int udf_cd001_vrs(struct super_block *sb, int silent);
+static int udf_nsr02_vrs(struct super_block *sb, long block, int silent);
+static int udf_load_partition(struct super_block *sb,struct AnchorVolDescPtr *);
+static int udf_load_logicalvol(struct super_block *sb,struct buffer_head *);
+static int udf_find_anchor(struct super_block *,long,struct AnchorVolDescPtr *);
+static int udf_find_fileset(struct super_block *sb);
+static void udf_load_pvoldesc(struct super_block *sb, struct buffer_head *);
+static void udf_load_fileset(struct super_block *sb, struct buffer_head *);
+static void udf_load_partdesc(struct super_block *sb, struct buffer_head *);
+static unsigned int udf_count_free(struct super_block *sb);
+
+static unsigned int isofs_get_last_session(kdev_t dev);
+/* version specific functions */
+#if LINUX_VERSION_CODE > 0x020100
+static int udf_statfs(struct super_block *, struct statfs *, int);
+#else
+static void udf_statfs(struct super_block *, struct statfs *, int);
+#endif
+
+/* some debug stuff */
+/*
+static void udf_dump_fileset(struct super_block *, struct buffer_head *);
+*/
+
+/* UDF filesystem type */
+#if LINUX_VERSION_CODE > 0x020100
+static struct file_system_type udf_fstype = {
+	"udf",			/* name */
+	FS_REQUIRES_DEV,	/* fs_flags */
+	udf_read_super,		/* read_super */
+	NULL			/* next */
+};
+#else
+static struct file_system_type udf_fstype = {
+	udf_read_super,		/* read_super */
+	"udf",			/* name */
+	1,			/* fs_flags */
+	NULL			/* next */
+};
+#endif
+
+/* Superblock operations */
+#if LINUX_VERSION_CODE > 0x020100
+static struct super_operations udf_sb_ops = {
+	udf_read_inode,		/* read_inode */
+	udf_write_inode,	/* write_inode */
+	udf_put_inode,		/* put_inode */
+	udf_delete_inode,	/* delete_inode */
+	NULL,			/* notify_change */
+	udf_put_super,		/* put_super */
+	NULL,			/* write_super */
+	udf_statfs,		/* statfs */
+	NULL			/* remount_fs */
+};
+#else
+static struct super_operations udf_sb_ops = {
+	udf_read_inode,		/* read_inode */
+	NULL,			/* notify_change */
+#ifdef CONFIG_UDF_WRITE
+	udf_write_inode,	/* write_inode */
+#else
+	NULL,			/* write_inode */
+#endif
+	udf_put_inode,		/* put_inode */
+	udf_put_super,		/* put_super */
+	NULL,			/* write_super */
+	udf_statfs,		/* statfs */
+	NULL			/* remount_fs */
+};
+#endif
+
+/* Debugging level. Affects all UDF filesystems! */
+int udf_debuglvl=0;
+int udf_strict=0;
+int udf_undelete=0;
+int udf_unhide=0;
+int udf_novrs=0; /* don't check for volume recognition seq */
+
+#ifdef NEED_COPY_TO_USER
+static inline unsigned long copy_to_user(void *to, 
+				const void *from, unsigned long n)
+{
+	int i;
+	if ((i = verify_area(VERIFY_WRITE, to, n)) != 0)
+		return i;
+	memcpy_tofs(to, from, n);
+	return 0;
+}
+#endif
+#ifdef NEED_GET_HARDBLOCKSIZE
+int get_hardblocksize(kdev_t dev)
+{
+	return 2048;
+}
+#endif
+#ifdef NEED_LE32_TO_CPU
+static inline unsigned long le32_to_cpu(unsigned long value)
+{
+	return value; /* for i386, others need ... */
+}
+#endif
+
+__initfunc(int init_udf_fs(void))
+{
+	printk(KERN_NOTICE "udf: filesystem v0.7 registered\n");
+	udf_debuglvl = UDF_DEBUG_NONE;
+	return register_filesystem(&udf_fstype);
+}
+
+#if defined(MODULE)
+#if LINUX_VERSION_CODE > 0x020170
+MODULE_PARM(udf_debuglvl, "i");
+MODULE_PARM(udf_strict, "i");
+MODULE_PARM(udf_undelete, "i");
+MODULE_PARM(udf_unhide, "i");
+#endif
+
+/*
+ * cleanup_module
+ *
+ * PURPOSE
+ *	Unregister the UDF filesystem type.
+ *
+ * DESCRIPTION
+ *	Clean-up before the module is unloaded.
+ *	This routine only applies when compiled as a module.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int
+cleanup_module(void)
+{
+	printk(KERN_NOTICE "udf: unregistering filesystem\n");
+	return unregister_filesystem(&udf_fstype);
+}
+
+/*
+ * init_module / init_udf_fs
+ *
+ * PURPOSE
+ *	Register the UDF filesystem type.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int init_module(void)
+{
+	return init_udf_fs();
+}
+#endif
+
+/*
+ * udf_parse_options
+ *
+ * PURPOSE
+ *	Parse mount options.
+ *
+ * DESCRIPTION
+ *	The following mount options are supported:
+ *
+ *	bs=		Set the block size.
+ *	debug=		Set the debugging level for _all_ UDF filesystems.
+ *	fixed		Disable removable media checks.
+ *	gid=		Set the default group.
+ *	mode=		Set the default mode.
+ *	strict		Set strict conformance.
+ *	uid=		Set the default user.
+ *	session=	Set the CDROM session (default= last)
+ *	anchor=		Override standard anchor location.
+ *	volume=		Override the VolumeDesc location.
+ *	partition=	Override the PartitionDesc location.
+ *	partroot=	Override the partitionStartingLocation.
+ *	fileset=	Override the fileset block location.
+ *	rootdir=	Override the root directory location.
+ *      unhide
+ *      undelete
+ *      novrs           Skip volume sequence recognition (my RW cd recorded by 
+ *                       ADAPTEC DirectCD 2.5 has no such sequence but otherwise is fine
+ *
+ * PRE-CONDITIONS
+ *	sb			Pointer to _locked_ superblock.
+ *	opts			Pointer to mount options string.
+ *
+ * POST-CONDITIONS
+ *	<return>	0	Mount options parsed okay.
+ *	<return>	-1	Error parsing mount options.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static  int
+udf_parse_options(struct super_block *sb, char *opts)
+{
+	char *opt, *val;
+
+#ifdef DEBUG
+	udf_debuglvl=2;
+#endif
+	/* Set defaults */
+	sb->s_blocksize = 0;
+	UDF_SB(sb)->s_flags = (udf_strict) ? UDF_FLAG_STRICT : 0;
+	UDF_SB(sb)->s_mode = S_IRUGO | S_IXUGO;
+	UDF_SB(sb)->s_gid = 0;
+	UDF_SB(sb)->s_uid = 0;
+
+	UDF_SB_SESSION(sb)=0;
+	UDF_SB_ANCHOR(sb)=0;
+	UDF_SB_VOLUME(sb)=0;
+	UDF_SB_PARTITION(sb)=0;
+	UDF_SB_PARTROOT(sb)=0;
+	UDF_SB_FILESET(sb)=0;
+	UDF_SB_ROOTDIR(sb)=0;
+
+	/* Break up the mount options */
+	for (opt = strtok(opts, ","); opt; opt = strtok(NULL, ",")) {
+
+		/* Make "opt=val" into two strings */
+		val = strchr(opt, '=');
+		if (val)
+			*(val++) = 0;
+		if (!strcmp(opt, "novrs") && !val)
+			udf_novrs= 1;  
+		else if (!strcmp(opt, "bs") && val)
+			sb->s_blocksize = simple_strtoul(val, NULL, 0);
+	        else if (!strcmp(opt, "debug") &&val)
+			udf_debuglvl = simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "fixed") && !val)
+			UDF_SB(sb)->s_flags |= UDF_FLAG_FIXED;
+		else if (!strcmp(opt, "unhide") && !val)
+			udf_unhide=1;
+		else if (!strcmp(opt, "undelete") && !val)
+			udf_undelete=1;
+		else if (!strcmp(opt, "gid") && val)
+			UDF_SB(sb)->s_gid = simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "mode") && val)
+			UDF_SB(sb)->s_mode = simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "strict") && !val)
+			UDF_SB(sb)->s_flags &= UDF_FLAG_STRICT;
+		else if (!strcmp(opt, "uid") && val)
+			UDF_SB(sb)->s_uid = simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "session") && val)
+			UDF_SB_SESSION(sb)= simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "anchor") && val)
+			UDF_SB_ANCHOR(sb)= simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "volume") && val)
+			UDF_SB_VOLUME(sb)= simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "partition") && val)
+			UDF_SB_PARTITION(sb)= simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "partroot") && val)
+			UDF_SB_PARTROOT(sb)= simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "fileset") && val)
+			UDF_SB_FILESET(sb)= simple_strtoul(val, NULL, 0);
+		else if (!strcmp(opt, "rootdir") && val)
+			UDF_SB_ROOTDIR(sb)= simple_strtoul(val, NULL, 0);
+		else if (val) {
+			printk(KERN_ERR "udf: bad mount option \"%s=%s\"\n",
+				opt, val);
+			return -1;
+		} else {
+			printk(KERN_ERR "udf: bad mount option \"%s\"\n",
+				opt);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/*
+ * udf_set_blocksize
+ *
+ * PURPOSE
+ *	Set the block size to be used in all transfers.
+ *
+ * DESCRIPTION
+ *	To allow room for a DMA transfer, it is best to guess big when unsure.
+ *	This routine picks 2048 bytes as the blocksize when guessing. This
+ *	should be adequate until devices with larger block sizes become common.
+ *
+ *	Note that the Linux kernel can currently only deal with blocksizes of
+ *	512, 1024, 2048, 4096, and 8192 bytes.
+ *
+ * PRE-CONDITIONS
+ *	sb			Pointer to _locked_ superblock.
+ *
+ * POST-CONDITIONS
+ *	sb->s_blocksize		Blocksize.
+ *	sb->s_blocksize_bits	log2 of blocksize.
+ *	<return>	0	Blocksize is valid.
+ *	<return>	1	Blocksize is invalid.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static  int
+udf_set_blocksize(struct super_block *sb)
+{
+	int blocksize;
+
+	/* Use specified block size if specified */
+	blocksize = get_hardblocksize(sb->s_dev);
+	blocksize = blocksize ? blocksize : 2048;
+	blocksize = sb->s_blocksize ? sb->s_blocksize: blocksize;
+
+	/* Block size must be an even multiple of 512 */
+	switch (blocksize) {
+		case 512:
+		sb->s_blocksize_bits = 9;
+		break;
+
+		case 1024:
+		sb->s_blocksize_bits = 10;
+		break;
+
+		case 0:
+		case 2048:
+		sb->s_blocksize_bits = 11;
+		break;
+
+		default:
+		printk(KERN_ERR "udf: bad block size (%d)\n", blocksize);
+		return -1;
+	}
+
+	/* Set the block size */
+	set_blocksize(sb->s_dev, blocksize);
+	sb->s_blocksize = blocksize;
+
+	return 0;
+}
+
+/*
+ * from fs/isofs
+ */
+static unsigned int 
+isofs_get_last_session(kdev_t dev)
+{
+  struct cdrom_multisession ms_info;
+  unsigned int vol_desc_start;
+  struct inode inode_fake;
+  extern struct file_operations * get_blkfops(unsigned int);
+  int i;
+
+  vol_desc_start=0;
+  if (get_blkfops(MAJOR(dev))->ioctl!=NULL) {
+      /* Whoops.  We must save the old FS, since otherwise
+       * we would destroy the kernels idea about FS on root
+       * mount in read_super... [chexum]
+       */
+      mm_segment_t old_fs=get_fs();
+      inode_fake.i_rdev=dev;
+      ms_info.addr_format=CDROM_LBA;
+      set_fs(KERNEL_DS);
+      i=get_blkfops(MAJOR(dev))->ioctl(&inode_fake,
+				       NULL,
+				       CDROMMULTISESSION,
+				       (unsigned long) &ms_info);
+      set_fs(old_fs);
+#ifdef DEBUG
+      if (i==0) {
+	  printk(KERN_INFO "udf: XA disk: %s\n", ms_info.xa_flag ? "yes":"no");
+	  printk(KERN_INFO "udf: vol_desc_start = %d\n", ms_info.addr.lba);
+      } else
+      	  printk(KERN_DEBUG "udf: CDROMMULTISESSION not supported: rc=%d\n",i);
+#endif
+
+#define WE_OBEY_THE_WRITTEN_STANDARDS 1
+
+      if (i==0) {
+#if WE_OBEY_THE_WRITTEN_STANDARDS
+        if (ms_info.xa_flag) /* necessary for a valid ms_info.addr */
+#endif
+          vol_desc_start=ms_info.addr.lba;
+      }
+  } else {
+	printk(KERN_DEBUG "udf: device doesn't know how to ioctl?\n");
+  }
+  return vol_desc_start;
+}
+
+#ifdef DEBUG
+#define ISODCL(from, to) (to - from + 1)
+
+#ifdef __linux__
+#pragma pack(1)
+#endif
+struct iso_primary_descriptor {
+	char type			[ISODCL (  1,   1)]; /* 711 */
+	char id				[ISODCL (  2,   6)];
+	char version			[ISODCL (  7,   7)]; /* 711 */
+	char unused1			[ISODCL (  8,   8)];
+	char system_id			[ISODCL (  9,  40)]; /* achars */
+	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
+	char unused2			[ISODCL ( 73,  80)];
+	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
+	char unused3			[ISODCL ( 89, 120)];
+	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
+	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
+	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
+	char path_table_size		[ISODCL (133, 140)]; /* 733 */
+	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
+	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
+	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
+	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
+	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
+	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
+	char publisher_id		[ISODCL (319, 446)]; /* achars */
+	char preparer_id		[ISODCL (447, 574)]; /* achars */
+	char application_id		[ISODCL (575, 702)]; /* achars */
+	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
+	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
+	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
+	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
+	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
+	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
+	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
+	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
+	char unused4			[ISODCL (883, 883)];
+	char application_data		[ISODCL (884, 1395)];
+	char unused5			[ISODCL (1396, 2048)];
+};
+#ifdef __linux__
+#pragma pack()
+#endif
+#endif
+
+/*
+ * udf_cd001_vrs
+ *
+ * PURPOSE
+ *	Process an ISO 9660 volume recognition sequence.
+ *
+ * DESCRIPTION
+ *	The block size must be a multiple of 2048.
+ *
+ * PRE-CONDITIONS
+ *	sb			Pointer to _locked_ superblock.
+ *
+ * POST-CONDITIONS
+ *	<return>		Last block + 1 processed.
+ *
+ * HISTORY
+ *	Oct 7, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static int
+udf_cd001_vrs(struct super_block *sb, int silent)
+{
+	struct VolStructDesc *vsd = NULL;
+
+	int sector = 32768 >> sb->s_blocksize_bits; 
+	/* normally sector=16, but that assumes blocksize 2048.         */
+	/* that's always true for ISO9660 volumes, but not other media */
+
+	struct buffer_head *bh;
+	int save_bea=0;
+	int iso9660=0;
+
+	DPRINTK(3,(KERN_DEBUG "udf: looking for ISO9660 volume recognition sequence\n"));
+
+	/* Block size must be a multiple of 2048 */
+	if (sb->s_blocksize & 2047)
+		return sector;
+
+	sector += UDF_SB_SESSION(sb);
+
+	printk(KERN_DEBUG "Starting at sector %u\n", sector);
+	/* Process the sequence (if applicable) */
+	for (;;) {
+		/* Read a block */
+		bh = bread(sb->s_dev, sector, sb->s_blocksize);
+		if (!bh)
+			break;
+
+		/* Look for ISO 9660 descriptors */
+		vsd = (struct VolStructDesc *)bh->b_data;
+
+		if (!strncmp(vsd->stdIdent, STD_ID_CD001, STD_ID_LEN))
+		{
+			switch (vsd->structType) {
+				case 0: 
+		printk(KERN_DEBUG "udf: ISO9660 Boot Record found\n"); break;
+				case 1: 
+		printk(KERN_DEBUG "udf: ISO9660 Primary Volume Descriptor found\n"); break;
+				case 2: 
+		printk(KERN_DEBUG "udf: ISO9660 Supplementary Volume Descriptor found\n"); break;
+				case 3: 
+		printk(KERN_DEBUG "udf: ISO9660 Volume Partition Descriptor found\n"); break;
+				case 255: 
+		printk(KERN_DEBUG "udf: ISO9660 Volume Descriptor Set Terminator found\n"); break;
+				default: 
+		printk(KERN_DEBUG "udf: ISO9660 VRS (%u) found\n", vsd->structType); break;
+			}
+			iso9660 = 1;
+#ifdef VDEBUG
+		  {
+		    struct iso_primary_descriptor * isopd;
+
+		    isopd=(struct iso_primary_descriptor *)bh->b_data;
+		    printk(KERN_DEBUG "udf: iso(%s) vss %u vsets %u\n",
+			isopd->volume_id, 
+			*(unsigned int *)&isopd->volume_space_size,
+			*(unsigned int *)&isopd->volume_set_size);
+		  }
+#endif
+		}
+
+		if (!strncmp(vsd->stdIdent, STD_ID_BEA01, STD_ID_LEN))
+		{
+			save_bea=sector;
+		}
+		if (!strncmp(vsd->stdIdent, STD_ID_TEA01, STD_ID_LEN))
+		{
+			if ( !IS_STRICT(sb) )
+			{
+				brelse(bh);
+				break;	
+			}
+		}
+		if (!strncmp(vsd->stdIdent, STD_ID_NSR02, STD_ID_LEN) ||
+		    !strncmp(vsd->stdIdent, STD_ID_NSR03, STD_ID_LEN))
+		{
+			save_bea = sector;
+			if (iso9660)
+				printk(KERN_DEBUG "udf: ISO9660 Bridge Disk Detected\n");
+			if ( !IS_STRICT(sb) )
+			{
+				brelse(bh);
+				break;
+			}
+		}
+
+		sector++;
+		brelse(bh);
+	}
+
+	if (IS_STRICT(sb) && vsd && (vsd->structType != 0xff) && !silent)
+		printk(KERN_INFO "udf: Incorrect volume recognition sequence. "
+			"Notify vendor!\n");
+
+	return save_bea;
+}
+
+/*
+ * udf_nsr02_vrs
+ *
+ * PURPOSE
+ *	Process an ISO 13346 volume recognition sequence.
+ *
+ * DESCRIPTION
+ *	This routine cannot handle block sizes > 2048.
+ *
+ * PRE-CONDITIONS
+ *	sb			Pointer to _locked_ superblock.
+ *	block			Block to start processing at.
+ *
+ * POST-CONDITIONS
+ *	<return>	0	Not NSR compliant.
+ *	<return>	1	NSR compliant.
+ *
+ * HISTORY
+ *	Oct 7, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static  int
+udf_nsr02_vrs(struct super_block *sb, long sector, int silent)
+{
+	struct VolStructDesc *vsd = NULL;
+	int block_inc = 2048 >> sb->s_blocksize_bits;
+	int is_nsr = 0;
+	struct buffer_head *bh;
+
+	DPRINTK(3,(KERN_INFO "udf: looking for ISO13346 volume recognition sequence\n"));
+
+	/* Avoid infinite loops */
+	if (!block_inc) {
+		printk(KERN_ERR "udf: can't handle blocks > 2048\n");
+		return 0;
+	}
+
+	/* Look for beginning of extended area */
+	if (IS_STRICT(sb)) {
+		bh = bread(sb->s_dev, sector++, sb->s_blocksize);
+		if (!bh)
+			return 0;
+		vsd = (struct VolStructDesc *)bh->b_data;
+		if (!strncmp(vsd->stdIdent, STD_ID_BEA01, STD_ID_LEN)) {
+			if (!silent)
+			  printk(KERN_ERR "udf: not an NSR compliant volume\n");
+			brelse(bh);
+			return 0;
+		}
+	}
+
+	/* Process the extended area */
+	for (;;) {
+		/* Read a block */
+		bh = bread(sb->s_dev, sector, sb->s_blocksize);
+		if (!bh)
+			break;
+
+		/* Process the descriptor */
+		vsd = (struct VolStructDesc *)bh->b_data;
+
+		if (!strncmp(vsd->stdIdent, STD_ID_BEA01, STD_ID_LEN)) {
+			;
+		} else if (!strncmp(vsd->stdIdent, STD_ID_BOOT2, STD_ID_LEN)) {
+			;
+		} else if (!strncmp(vsd->stdIdent, STD_ID_CD001, STD_ID_LEN)) {
+			;
+		} else if (!strncmp(vsd->stdIdent, STD_ID_CDW02, STD_ID_LEN)) {
+			;
+		} else if (!strncmp(vsd->stdIdent, STD_ID_NSR02, STD_ID_LEN)) {
+			is_nsr = 1;
+		} else if (!strncmp(vsd->stdIdent, STD_ID_TEA01, STD_ID_LEN)) {
+			brelse(bh);
+			break;
+		} else {
+			brelse(bh);
+			break;
+		}
+		brelse(bh);
+		sector += block_inc;
+	}
+
+	return is_nsr;
+}
+
+/*
+ * udf_find_anchor
+ *
+ * PURPOSE
+ *	Find an anchor volume descriptor.
+ *
+ * PRE-CONDITIONS
+ *	sb			Pointer to _locked_ superblock.
+ *	lastblock		Last block on media.
+ *
+ * POST-CONDITIONS
+ *	<return>		1 if not found, 0 if ok
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static  int
+udf_find_anchor(struct super_block *sb, long lastblock, 
+	struct AnchorVolDescPtr *ap)
+{
+	struct buffer_head *bh;
+	long ablock;
+
+	/* Search for an anchor volume descriptor pointer */
+
+	/*  according to spec, anchor is in either:
+	 *     block 256
+	 *     lastblock-256
+	 *     lastblock
+	 *  however, if the disc isn't closed, it could be 512 */
+ 
+	ablock=256 + UDF_SB_SESSION(sb);
+	bh = udf_read_tagged(sb, ablock,0);
+	if (!bh || ((tag *)bh->b_data)->tagIdent != TID_ANCHOR_VOL_DESC_PTR) {
+		udf_release_data(bh);
+		ablock=512 + UDF_SB_SESSION(sb);
+		bh = udf_read_tagged(sb, ablock,0);
+	}
+#ifdef UDF_NEED_BETTER_LASTBLOCK
+	if (!bh || ((tag *)bh->b_data)->tagIdent != TID_ANCHOR_VOL_DESC_PTR) {
+		udf_release_data(bh);
+		ablock=lastblock-256;
+		bh = udf_read_tagged(sb, ablock,0);
+	}
+	if (!bh || ((tag *)bh->b_data)->tagIdent != TID_ANCHOR_VOL_DESC_PTR) {
+		udf_release_data(bh);
+		ablock=lastblock;
+		bh = udf_read_tagged(sb, ablock,0);
+	}
+#endif
+	if (!bh || ((tag *)bh->b_data)->tagIdent != TID_ANCHOR_VOL_DESC_PTR) {
+		udf_release_data(bh);
+		ablock=512 + UDF_SB_SESSION(sb);
+		bh = udf_read_tagged(sb, ablock,0);
+	}
+	if (!bh || ((tag *)bh->b_data)->tagIdent != TID_ANCHOR_VOL_DESC_PTR) {
+		udf_release_data(bh);
+		printk(KERN_ERR "udf: couldn't find an anchor\n");
+		return 1;
+	}
+	UDF_SB_ANCHOR(sb)=ablock;
+	memcpy(ap, bh->b_data, sizeof(struct AnchorVolDescPtr));
+	udf_release_data(bh);
+	return 0;
+}
+
+static int 
+udf_find_fileset(struct super_block *sb)
+{
+	struct buffer_head *bh=NULL;
+	tag * tagp;
+	long block, lastblock, offset;
+	int done=0;
+
+	offset=block=UDF_SB_PARTROOT(sb);
+
+	/* lastblock=UDF_SB_LASTBLOCK(sb); */ /* don't know how yet */
+	lastblock=block+100; /* look in the first 100 sectors */
+
+	if (UDF_SB_FILESET(sb)) {
+		/* set by LogicalVolDesc or mount option */
+	    	bh = udf_read_tagged(sb, UDF_SB_FILESET(sb)+offset, offset);
+	    	if (!bh) {
+			return 1;
+	    	}
+	} else {
+	    while ( (!done) && (block < lastblock)) {
+		printk(KERN_DEBUG "udf: find_fileset block %lu?\n", 
+			block-offset);
+	    	bh = udf_read_tagged(sb, block, offset);
+	    	if (!bh) {
+			block++;
+			continue;
+	    	}
+	    
+	    	tagp=(tag *)bh->b_data;
+
+		switch ( tagp->tagIdent ) {
+		case TID_SPACE_BITMAP_DESC:
+			{
+				/* these are untagged! */
+				/* carefully skip to avoid being fooled */
+				struct SpaceBitmapDesc *sp;
+				sp=(struct SpaceBitmapDesc *)bh->b_data;
+				block +=sp->numOfBytes/sb->s_blocksize;
+				/* skip bitmap sectors */
+			}
+			break;
+		case TID_FILE_SET_DESC:
+			UDF_SB_FILESET(sb)=block-offset;
+			done=1;
+			break;
+		case TID_FILE_ENTRY:
+			break;
+		default:
+			break;
+		}
+		udf_release_data(bh);
+
+	    	block++;
+	    } /* end while */
+	}
+	if ( (UDF_SB_FILESET(sb)) && (bh) ) {
+		printk(KERN_DEBUG "udf: (%d) FileSet is at block %d\n",
+			UDF_SB_PARTITION(sb), UDF_SB_FILESET(sb));
+		udf_load_fileset(sb, bh);
+		return 0;
+	}
+	return 1;
+}
+
+static void 
+udf_load_pvoldesc(struct super_block *sb, struct buffer_head *bh)
+{
+	struct PrimaryVolDesc *pvoldesc;
+	time_t recording;
+	struct ustr instr;
+	struct ustr outstr;
+
+	pvoldesc=(struct PrimaryVolDesc *)bh->b_data;
+
+	if ( udf_stamp_to_time(&recording, &pvoldesc->recordingDateAndTime) ) {
+	    timestamp *ts;
+	    ts=&pvoldesc->recordingDateAndTime;
+	    printk(KERN_INFO "udf: recording time %ld, %u/%u/%u %u:%u (%x)\n", 
+		recording, ts->year, ts->month, ts->day, ts->hour, ts->minute,
+		ts->typeAndTimezone);
+	    UDF_SB_RECORDTIME(sb)=recording;
+	    memcpy( &UDF_SB_TIMESTAMP(sb), ts, sizeof(timestamp));
+	}
+	if ( !udf_build_ustr(&instr, pvoldesc->volIdent, 32) ) {
+		if (!udf_CS0toUTF8(&outstr, &instr)) {
+	    		printk(KERN_INFO "udf: volIdent[] = '%s'\n", outstr.u_name);
+			strncpy( UDF_SB_VOLIDENT(sb), outstr.u_name, 32);
+		}
+	}
+	if ( !udf_build_ustr(&instr, pvoldesc->volSetIdent, 128) ) {
+		if (!udf_CS0toUTF8(&outstr, &instr)) {
+	    		printk(KERN_INFO "udf: volSetIdent[] = '%s'\n", outstr.u_name);
+		}
+	}
+}
+
+static void 
+udf_load_fileset(struct super_block *sb, struct buffer_head *bh)
+{
+	struct FileSetDesc *fset;
+	long_ad *r;
+
+	fset=(struct FileSetDesc *)bh->b_data;
+	r=&fset->rootDirectoryICB;
+	if (UDF_SB_ROOTDIR(sb)) {
+		UDF_SB_ROOTDIR(sb) -= UDF_SB_PARTROOT(sb);
+		printk(KERN_INFO "udf: (%d) RootDir at %u, override to %u\n",
+			r->extLocation.partitionReferenceNum,
+			r->extLocation.logicalBlockNum, UDF_SB_ROOTDIR(sb));
+	} else {
+		UDF_SB_ROOTDIR(sb)= r->extLocation.logicalBlockNum;
+	}
+	printk(KERN_INFO "udf: (%d) RootDir is at block %u (+ %u= sector %lu), %u bytes\n",
+		r->extLocation.partitionReferenceNum,
+		r->extLocation.logicalBlockNum,
+		UDF_SB_PARTROOT(sb), 
+		udf_block_from_inode(sb,UDF_SB_ROOTDIR(sb)),
+		r->extLength);
+	
+}
+
+static void 
+udf_load_partdesc(struct super_block *sb, struct buffer_head *bh)
+{
+	struct PartitionDesc *p;
+	p=(struct PartitionDesc *)bh->b_data;
+
+	UDF_SB_PARTITION(sb)=p->partitionNumber;
+	UDF_SB_PARTLEN(sb)=p->partitionLength; /* blocks */
+	if (UDF_SB_PARTROOT(sb)) {
+		printk(KERN_INFO "udf: partition(%d) override (%d) at sector %d, block length %d\n",
+			p->partitionNumber, 
+			(p->partitionStartingLocation + UDF_SB_SESSION(sb)),
+			UDF_SB_PARTROOT(sb), UDF_SB_PARTLEN(sb));
+	} else {
+		UDF_SB_PARTROOT(sb)=p->partitionStartingLocation 
+			+ UDF_SB_SESSION(sb);
+		printk(KERN_INFO "udf: partition(%d) at sector %d, block length %d\n",
+			p->partitionNumber,
+			UDF_SB_PARTROOT(sb), UDF_SB_PARTLEN(sb));
+	}
+}
+
+static int 
+udf_load_logicalvol(struct super_block *sb,struct buffer_head * bh)
+{
+	struct LogicalVolDesc *p;
+	long_ad * la;
+	p=(struct LogicalVolDesc *)bh->b_data;
+
+	la=(long_ad *)p->logicalVolContentsUse;
+	printk(KERN_DEBUG "udf: '%s' lvcu loc lbn %lu ref %u len %lu\n",
+		p->logicalVolIdent,
+		(long unsigned)la->extLocation.logicalBlockNum, 
+		la->extLocation.partitionReferenceNum,
+		(long unsigned)la->extLength);
+	if (!UDF_SB_FILESET(sb)) {
+		UDF_SB_FILESET(sb)= la->extLocation.logicalBlockNum;
+		printk(KERN_DEBUG "udf: FileSet(%d) found in LogicalVolDesc at %d\n",
+			la->extLocation.partitionReferenceNum,
+			UDF_SB_FILESET(sb));
+	}
+	return 0;
+}
+
+/*
+ * udf_process_sequence
+ *
+ * PURPOSE
+ *	Process a main/reserve volume descriptor sequence.
+ *
+ * PRE-CONDITIONS
+ *	sb			Pointer to _locked_ superblock.
+ *	block			First block of first extent of the sequence.
+ *	lastblock		Lastblock of first extent of the sequence.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static  int
+udf_process_sequence(struct super_block *sb, long block, long lastblock)
+{
+	struct buffer_head *bh;
+	__u32 descIdent = TID_UNUSED_DESC;
+
+	/* Read the main descriptor sequence */
+	for (; (descIdent != TID_TERMINATING_DESC) &&
+	       (block <= lastblock); block++) {
+
+		bh = udf_read_tagged(sb, block,0);
+		if (!bh) 
+			break;
+
+		/* Process each descriptor (ISO 13346 3/8.3-8.4) */
+		descIdent = ((tag *)bh->b_data)->tagIdent;
+		switch (descIdent) {
+			case TID_PRIMARY_VOL_DESC: /* ISO 13346 3/10.1 */
+			udf_load_pvoldesc(sb, bh);
+			break;
+
+			case TID_VOL_DESC_PTR: /* ISO 13346 3/10.3 */
+			/*lastblock = block = le32_to_cpu(*/
+			lastblock = le32_to_cpu(
+				((struct AnchorVolDescPtr *)bh->b_data)
+				->mainVolDescSeqExt.extLocation);
+			lastblock += le32_to_cpu(((struct AnchorVolDescPtr *)
+				bh->b_data)->mainVolDescSeqExt.extLength)
+				 >> sb->s_blocksize_bits;
+			if ( udf_debuglvl )
+			  printk(KERN_ERR "udf: newlastblock = %lu\n",
+					lastblock);
+			break;
+
+			case TID_IMP_USE_VOL_DESC: /* ISO 13346 3/10.4 */
+			break;
+
+			case TID_PARTITION_DESC: /* ISO 13346 3/10.5 */
+			udf_load_partdesc(sb, bh);
+			break;
+
+			case TID_LOGICAL_VOL_DESC: /* ISO 13346 3/10.6 */
+			udf_load_logicalvol(sb, bh);
+			break;
+
+			case TID_UNALLOC_SPACE_DESC: /* ISO 13346 3/10.8 */
+			break;
+
+			case TID_TERMINATING_DESC: /* ISO 13346 3/10.9 */
+			break;
+
+			case TID_FILE_SET_DESC:
+			break;
+
+			case TID_FILE_IDENT_DESC:
+			break;
+	
+			default:
+			break;
+		}
+		udf_release_data(bh);
+	}
+	return 0;
+}
+
+/*
+ * udf_check_valid()
+ */
+static int
+udf_check_valid(struct super_block *sb, int silent)
+{
+	long block;
+
+	if ( !UDF_SB_SESSION(sb) )
+		UDF_SB_SESSION(sb)=isofs_get_last_session(sb->s_dev);
+	if ( UDF_SB_SESSION(sb) && !silent )
+		printk(KERN_INFO "udf: multi-session=%d\n", UDF_SB_SESSION(sb));
+
+	/* Check that it is NSR02 compliant */
+	/* Process any "CD-ROM Volume Descriptor Set" (ECMA 167 2/8.3.1) */
+	block = udf_cd001_vrs(sb, silent);
+	if (!block) 	/* block = begining of extended area block */
+		return 1;
+
+	/* Check that it is NSR02 compliant */
+	if (!udf_nsr02_vrs(sb, block, silent)) { /* expects block = BEA block */
+		printk(KERN_ERR "udf: volume is not NSR02 compliant\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int
+udf_load_partition(struct super_block *sb,struct AnchorVolDescPtr *anchor)
+{
+	long main_s, main_e, reserve_s, reserve_e;
+
+	if (!sb)
+	    return 1;
+	/* Locate the main sequence */
+	main_s = le32_to_cpu( anchor->mainVolDescSeqExt.extLocation );
+	main_e = le32_to_cpu( anchor->mainVolDescSeqExt.extLength );
+	main_e = main_e >> sb->s_blocksize_bits;
+	main_e += main_s;
+	UDF_SB_VOLDESC(sb)=main_s;
+
+
+	/* Locate the reserve sequence */
+	reserve_s = le32_to_cpu(anchor->mainVolDescSeqExt.extLocation);
+	reserve_e = le32_to_cpu(anchor->mainVolDescSeqExt.extLength);
+	reserve_e = reserve_e >> sb->s_blocksize_bits;
+	reserve_e += reserve_s;
+
+	UDF_SB_LASTBLOCK(sb)= (main_e > reserve_e) ? main_e : reserve_e;
+
+	/* Process the main & reserve sequences */
+	/* responsible for finding the PartitionDesc(s) */
+	if ( udf_process_sequence(sb, main_s, main_e) &&
+	     udf_process_sequence(sb, reserve_s, reserve_e) )
+		return 1;
+	return 0;
+}
+
+/*
+ * udf_read_super
+ *
+ * PURPOSE
+ *	Complete the specified super block.
+ *
+ * PRE-CONDITIONS
+ *	sb			Pointer to superblock to complete - never NULL.
+ *	sb->s_dev		Device to read suberblock from.
+ *	options			Pointer to mount options.
+ *	silent			Silent flag.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static struct super_block *
+udf_read_super(struct super_block *sb, void *options, int silent)
+{
+	struct inode *inode=NULL;
+	struct AnchorVolDescPtr anchor;
+	long lastblock=512;
+
+	/* Lock the module in memory (if applicable) */
+	MOD_INC_USE_COUNT;
+
+	lock_super(sb);
+	UDF_SB_ALLOC(sb); /* kmalloc, if needed */
+	UDF_SB_SESSION(sb)=0; /* for multisession discs */
+	UDF_SB_ANCHOR(sb)=0;
+	UDF_SB_VOLDESC(sb)=0;
+	UDF_SB_LASTBLOCK(sb)=0;
+	UDF_SB_FILESET(sb)=0;
+	UDF_SB_RECORDTIME(sb)=0;
+	UDF_SB_PARTROOT(sb)=0;
+	UDF_SB_PARTLEN(sb)=0;
+	UDF_SB_FILECOUNT(sb)=0;
+	UDF_SB_VOLIDENT(sb)[0]=0;
+
+	/* Parse any mount options */
+	if (udf_parse_options(sb, (char *)options))
+		goto error_out;
+
+	/* Set the block size for all transfers */
+	if (udf_set_blocksize(sb))
+		goto error_out;
+	if  (!udf_novrs){
+		if (udf_check_valid(sb, silent)) /* read volume recognition sequences */
+ 		 goto error_out;
+	}
+	else
+ 		printk(KERN_ERR "udf: validity check skipped because of novrs option\n");
+
+	if (!UDF_SB_ANCHOR(sb)) {
+	    /* Find an anchor volume descriptor pointer */
+	    /* dgb: how do we determine the last block before this point? */
+	    if (udf_find_anchor(sb, lastblock, &anchor)) {
+		printk(KERN_ERR "udf: no anchor block found\n");
+		goto error_out;
+	    }
+	}
+
+	if (udf_load_partition(sb, &anchor)) {
+		printk(KERN_ERR "udf: no partition found\n");
+		goto error_out;
+	}
+
+	if ( !UDF_SB_PARTROOT(sb) ) {
+		printk(KERN_ERR "udf: no partition found (2)\n");
+		goto error_out;
+	}
+	if ( udf_find_fileset(sb) ) {
+		printk(KERN_ERR "udf: no fileset found\n");
+		goto error_out;
+	}
+
+	if (!silent) {
+		timestamp *ts;
+		ts= &UDF_SB_TIMESTAMP(sb);
+		printk(KERN_NOTICE "udf: mounting volume '%s', timestamp %u/%02u/%u %02u:%02u\n",
+			UDF_SB_VOLIDENT(sb), ts->year, ts->month, ts->day, ts->hour, ts->minute);
+	}
+		
+	/* Fill in the rest of the superblock */
+	sb->s_op = &udf_sb_ops;
+	sb->s_time = 0;
+	sb->dq_op = NULL;
+	sb->s_dirt = 0;
+	sb->s_magic = UDF_SUPER_MAGIC;
+	sb->s_flags |= MS_NODEV | MS_NOSUID; /* should be overridden by mount */
+#ifndef CONFIG_UDF_WRITE
+	sb->s_flags |= MS_RDONLY;
+#endif
+
+	/* Assign the root inode */
+	/* assign inodes by physical block number */
+	/* perhaps it's not extensible enough, but for now ... */
+	inode = udf_iget(sb, UDF_SB_ROOTDIR(sb) ); 
+	if (!inode) {
+		printk(KERN_DEBUG "udf: error in udf_iget(, %d)\n",
+			UDF_SB_ROOTDIR(sb) );
+		goto error_out;
+	}
+
+#if LINUX_VERSION_CODE > 0x020170
+	/* Allocate a dentry for the root inode */
+	sb->s_root = d_alloc_root(inode, NULL);
+	if (!sb->s_root) {
+		iput(inode);
+		printk(KERN_DEBUG "udf: couldn't allocate root dentry\n");
+		goto error_out;
+	}
+#endif
+
+	unlock_super(sb);
+	return sb;
+
+error_out:
+	sb->s_dev = NODEV;
+	UDF_SB_FREE(sb);
+	unlock_super(sb);
+	MOD_DEC_USE_COUNT;
+	return NULL;
+}
+
+/*
+ * udf_put_super
+ *
+ * PURPOSE
+ *	Prepare for destruction of the superblock.
+ *
+ * DESCRIPTION
+ *	Called before the filesystem is unmounted.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+static void
+udf_put_super(struct super_block *sb)
+{
+	UDF_SB_FREE(sb);
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * udf_stat_fs
+ *
+ * PURPOSE
+ *	Return info about the filesystem.
+ *
+ * DESCRIPTION
+ *	Called by sys_statfs()
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+#if LINUX_VERSION_CODE > 0x020100
+static int
+#else
+static void
+#endif
+udf_statfs(struct super_block *sb, struct statfs *buf, int bufsize)
+{
+	int size;
+	struct statfs tmp;
+	int rc;
+
+	size = (bufsize < sizeof(tmp)) ? bufsize: sizeof(tmp);
+
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.f_type = UDF_SUPER_MAGIC;
+	tmp.f_bsize = sb->s_blocksize;
+	tmp.f_blocks = UDF_SB_PARTLEN(sb);
+	tmp.f_bavail = udf_count_free(sb);
+	tmp.f_bfree = tmp.f_bavail;
+	tmp.f_files = UDF_SB_FILECOUNT(sb);
+	tmp.f_ffree = 0L;
+	/* __kernel_fsid_t f_fsid */
+	tmp.f_namelen = UDF_NAME_LEN;
+
+	rc= copy_to_user(buf, &tmp, size) ? -EFAULT: 0;
+#if LINUX_VERSION_CODE > 0x020100
+	return rc;
+#endif
+}
+
+static unsigned char udf_bitmap_lookup[16] = {
+	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4
+};
+	
+static unsigned int
+udf_count_free(struct super_block *sb)
+{
+	struct buffer_head *bh;
+	struct SpaceBitmapDesc *bm;
+	unsigned int accum=0;
+	int index;
+	int block;
+	Uint32  bytes;
+	Uint8   value;
+	Uint8 * ptr;
+
+	block=UDF_SB_PARTROOT(sb);
+	bh = udf_read_tagged(sb, block++, UDF_SB_PARTROOT(sb));
+	if (!bh) {
+		printk(KERN_ERR "udf: udf_count_free failed\n");
+		return 0;
+	}
+	bm=(struct SpaceBitmapDesc *)bh->b_data;
+	bytes=bm->numOfBytes;
+	bytes += 24;
+	index=24; /* offset in first block only */
+	ptr=(Uint8 *)bh->b_data;
+
+	while ( bytes > 0 ) {
+		while ((bytes > 0) && (index < sb->s_blocksize)) {
+			value=ptr[index];
+			accum += udf_bitmap_lookup[ value & 0x0f ];
+			accum += udf_bitmap_lookup[ value >> 4 ];
+			index++;
+			bytes--;
+		}
+		if ( bytes ) {
+			udf_release_data(bh);
+			bh = bread(sb->s_dev, block++, sb->s_blocksize);
+			if (!bh) {
+			  printk(KERN_DEBUG "udf: udf_count_free failed\n");
+			  return accum;
+			}
+			index=0;
+			ptr=(Uint8 *)bh->b_data;
+		}
+	}
+	udf_release_data(bh);
+	return accum;
+}
diff -u --recursive --new-file v2.1.129/linux/fs/udf/udfdecl.h linux/fs/udf/udfdecl.h
--- v2.1.129/linux/fs/udf/udfdecl.h	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/udfdecl.h	Sun Nov 29 14:45:29 1998
@@ -0,0 +1,19 @@
+#ifndef __UDF_DECL_H
+#define __UDF_DECL_H
+
+extern struct file_operations udf_file_fops;
+extern struct file_operations udf_dir_fops;
+extern struct inode_operations udf_dir_inode_operations;
+extern struct inode_operations udf_file_inode_operations;
+
+extern int udf_physical_lookup(struct inode *, struct dentry *);
+extern int udf_lookup(struct inode *, struct dentry *);
+
+extern void udf_read_inode(struct inode *);
+extern void udf_put_inode(struct inode *);
+extern void udf_delete_inode(struct inode *);
+extern void udf_write_inode(struct inode *);
+extern struct inode *udf_iget(struct super_block *, unsigned long);
+extern int udf_bmap(struct inode *, int block);
+
+#endif
diff -u --recursive --new-file v2.1.129/linux/fs/udf/udftime.c linux/fs/udf/udftime.c
--- v2.1.129/linux/fs/udf/udftime.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/udftime.c	Sun Nov 29 14:45:29 1998
@@ -0,0 +1,316 @@
+/* Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Eggert (eggert@twinsun.com).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * dgb 10/2/98: ripped this from glibc source to help convert timestamps to unix time 
+ *     10/4/98: added new table-based lookup after seeing how ugly the gnu code is
+ */
+
+/* Assume that leap seconds are possible, unless told otherwise.
+   If the host has a `zic' command with a `-L leapsecondfilename' option,
+   then it supports leap seconds; otherwise it probably doesn't.  */
+#ifndef LEAP_SECONDS_POSSIBLE
+#define LEAP_SECONDS_POSSIBLE 1
+#endif
+
+#if defined(__linux__) && defined(__KERNEL__)
+#include <linux/types.h>
+#include <linux/kernel.h>
+#else
+#include <stdio.h>
+#include <sys/types.h>
+#endif
+
+#include <linux/udf_fs.h>
+
+#ifndef CHAR_BIT
+#define CHAR_BIT 8
+#endif
+
+#ifndef INT_MIN
+#define INT_MIN (~0 << (sizeof (int) * CHAR_BIT - 1))
+#endif
+#ifndef INT_MAX
+#define INT_MAX (~0 - INT_MIN)
+#endif
+
+#ifndef TIME_T_MIN
+#define TIME_T_MIN (0 < (time_t) -1 ? (time_t) 0 \
+		    : ~ (time_t) 0 << (sizeof (time_t) * CHAR_BIT - 1))
+#endif
+#ifndef TIME_T_MAX
+#define TIME_T_MAX (~ (time_t) 0 - TIME_T_MIN)
+#endif
+
+#define TM_YEAR_BASE 1900
+#define EPOCH_YEAR 1970
+
+#ifndef __isleap
+/* Nonzero if YEAR is a leap year (every 4 years,
+   except every 100th isn't, and every 400th is).  */
+#define	__isleap(year)	\
+  ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
+#endif
+
+/* How many days come before each month (0-12).  */
+const unsigned short int __mon_yday[2][13] =
+  {
+    /* Normal years.  */
+    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    /* Leap years.  */
+    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+  };
+
+time_t udf_converttime (struct ktm *);
+#ifndef USE_GNU_MKTIME_METHOD
+
+#define MAX_YEAR_SECONDS	68
+
+time_t year_seconds[MAX_YEAR_SECONDS]= {
+	0, 
+	/*1971:*/ 31554000, /*1972:*/ 63090000, /*1973:*/ 94712400,
+ 	/*1974:*/ 126248400, /*1975:*/ 157784400, /*1976:*/ 189320400,
+ 	/*1977:*/ 220942800, /*1978:*/ 252478800, /*1979:*/ 284014800,
+ 	/*1980:*/ 315550800, /*1981:*/ 347173200, /*1982:*/ 378709200,
+ 	/*1983:*/ 410245200, /*1984:*/ 441781200, /*1985:*/ 473403600,
+ 	/*1986:*/ 504939600, /*1987:*/ 536475600, /*1988:*/ 568011600,
+ 	/*1989:*/ 599634000, /*1990:*/ 631170000, /*1991:*/ 662706000,
+ 	/*1992:*/ 694242000, /*1993:*/ 725864400, /*1994:*/ 757400400,
+ 	/*1995:*/ 788936400, /*1996:*/ 820472400, /*1997:*/ 852094800,
+ 	/*1998:*/ 883630800, /*1999:*/ 915166800, /*2000:*/ 946702800,
+ 	/*2001:*/ 978325200, /*2002:*/ 1009861200, /*2003:*/ 1041397200,
+ 	/*2004:*/ 1072933200, /*2005:*/ 1104555600, /*2006:*/ 1136091600,
+ 	/*2007:*/ 1167627600, /*2008:*/ 1199163600, /*2009:*/ 1230786000,
+ 	/*2010:*/ 1262322000, /*2011:*/ 1293858000, /*2012:*/ 1325394000,
+ 	/*2013:*/ 1357016400, /*2014:*/ 1388552400, /*2015:*/ 1420088400,
+ 	/*2016:*/ 1451624400, /*2017:*/ 1483246800, /*2018:*/ 1514782800,
+ 	/*2019:*/ 1546318800, /*2020:*/ 1577854800, /*2021:*/ 1609477200,
+ 	/*2022:*/ 1641013200, /*2023:*/ 1672549200, /*2024:*/ 1704085200,
+ 	/*2025:*/ 1735707600, /*2026:*/ 1767243600, /*2027:*/ 1798779600,
+ 	/*2028:*/ 1830315600, /*2029:*/ 1861938000, /*2030:*/ 1893474000,
+ 	/*2031:*/ 1925010000, /*2032:*/ 1956546000, /*2033:*/ 1988168400,
+ 	/*2034:*/ 2019704400, /*2035:*/ 2051240400, /*2036:*/ 2082776400,
+ 	/*2037:*/ 2114398800
+};
+
+time_t udf_converttime (struct ktm *tm)
+{
+    time_t r;
+    int yday;
+
+    if ( !tm )
+	return -1;
+    if ( (tm->tm_year+TM_YEAR_BASE < EPOCH_YEAR) || 
+	 (tm->tm_year+TM_YEAR_BASE > EPOCH_YEAR+MAX_YEAR_SECONDS) )
+	return -1;
+    r=year_seconds[tm->tm_year-70];
+
+    yday = ((__mon_yday[__isleap (tm->tm_year + TM_YEAR_BASE)]
+	       [tm->tm_mon-1])
+	      + tm->tm_mday - 1);
+    r+= ( ( (yday* 24) + (tm->tm_hour-1) ) * 60 + tm->tm_min ) * 60 + tm->tm_sec;
+    return r;
+}
+
+#else
+
+static time_t ydhms_tm_diff (int, int, int, int, int, const struct ktm *);
+
+
+/* Yield the difference between (YEAR-YDAY HOUR:MIN:SEC) and (*TP),
+   measured in seconds, ignoring leap seconds.
+   YEAR uses the same numbering as TM->tm_year.
+   All values are in range, except possibly YEAR.
+   If overflow occurs, yield the low order bits of the correct answer.  */
+static time_t
+ydhms_tm_diff (int year, int yday, int hour, int min, int sec, const struct ktm *tp)
+{
+  time_t result;
+
+  /* Compute intervening leap days correctly even if year is negative.
+     Take care to avoid int overflow.  time_t overflow is OK, since
+     only the low order bits of the correct time_t answer are needed.
+     Don't convert to time_t until after all divisions are done, since
+     time_t might be unsigned.  */
+  int a4 = (year >> 2) + (TM_YEAR_BASE >> 2) - ! (year & 3);
+  int b4 = (tp->tm_year >> 2) + (TM_YEAR_BASE >> 2) - ! (tp->tm_year & 3);
+  int a100 = a4 / 25 - (a4 % 25 < 0);
+  int b100 = b4 / 25 - (b4 % 25 < 0);
+  int a400 = a100 >> 2;
+  int b400 = b100 >> 2;
+  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);
+  time_t years = year - (time_t) tp->tm_year;
+  time_t days = (365 * years + intervening_leap_days);
+  result= (60 * (60 * (24 * days + (hour - tp->tm_hour))
+		+ (min - tp->tm_min))
+	  + (sec - tp->tm_sec));
+#ifdef __KERNEL__
+  printk(KERN_ERR "udf: ydhms_tm_diff(%d,%d,%d,%d,%d,) returning %ld\n",
+	year, yday, hour, min, sec, result);
+#endif
+  return result;
+}
+
+
+/* Convert *TP to a time_t value, inverting
+   the monotonic and mostly-unit-linear conversion function CONVERT.
+   Use *OFFSET to keep track of a guess at the offset of the result,
+   compared to what the result would be for UTC without leap seconds.
+   If *OFFSET's guess is correct, only one CONVERT call is needed.  */
+time_t
+udf_converttime (struct ktm *tp)
+{
+  time_t t, dt, t0;
+  struct ktm tm;
+
+  /* The maximum number of probes (calls to CONVERT) should be enough
+     to handle any combinations of time zone rule changes, solar time,
+     and leap seconds.  Posix.1 prohibits leap seconds, but some hosts
+     have them anyway.  */
+  int remaining_probes = 4;
+
+  /* Time requested.  Copy it in case CONVERT modifies *TP; this can
+     occur if TP is localtime's returned value and CONVERT is localtime.  */
+  int sec = tp->tm_sec;
+  int min = tp->tm_min;
+  int hour = tp->tm_hour;
+  int mday = tp->tm_mday;
+  int mon = tp->tm_mon;
+  int year_requested = tp->tm_year;
+  int isdst = tp->tm_isdst;
+
+  /* Ensure that mon is in range, and set year accordingly.  */
+  int mon_remainder = mon % 12;
+  int negative_mon_remainder = mon_remainder < 0;
+  int mon_years = mon / 12 - negative_mon_remainder;
+  int year = year_requested + mon_years;
+
+  /* The other values need not be in range:
+     the remaining code handles minor overflows correctly,
+     assuming int and time_t arithmetic wraps around.
+     Major overflows are caught at the end.  */
+
+  /* Calculate day of year from year, month, and day of month.
+     The result need not be in range.  */
+  int yday = ((__mon_yday[__isleap (year + TM_YEAR_BASE)]
+	       [mon_remainder + 12 * negative_mon_remainder])
+	      + mday - 1);
+
+#if LEAP_SECONDS_POSSIBLE
+  /* Handle out-of-range seconds specially,
+     since ydhms_tm_diff assumes every minute has 60 seconds.  */
+  int sec_requested = sec;
+  if (sec < 0)
+    sec = 0;
+  if (59 < sec)
+    sec = 59;
+#endif
+
+  /* Invert CONVERT by probing.  First assume the same offset as last time.
+     Then repeatedly use the error to improve the guess.  */
+
+  tm.tm_year = EPOCH_YEAR - TM_YEAR_BASE;
+  tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
+  /*
+  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &tm);
+
+  for (t = t0; 
+       (dt = ydhms_tm_diff (year, yday, hour, min, sec, &tm));
+       t += dt)
+    if (--remaining_probes == 0)
+      return -1;
+  */
+
+  /* Check whether tm.tm_isdst has the requested value, if any.  */
+  if (0 <= isdst && 0 <= tm.tm_isdst)
+    {
+      int dst_diff = (isdst != 0) - (tm.tm_isdst != 0);
+      if (dst_diff)
+	{
+	  /* Move two hours in the direction indicated by the disagreement,
+	     probe some more, and switch to a new time if found.
+	     The largest known fallback due to daylight savings is two hours:
+	     once, in Newfoundland, 1988-10-30 02:00 -> 00:00.  */
+	  time_t ot = t - 2 * 60 * 60 * dst_diff;
+	  while (--remaining_probes != 0)
+	    {
+	      struct ktm otm;
+	      if (! (dt = ydhms_tm_diff (year, yday, hour, min, sec,
+					 &otm)))
+		{
+		  t = ot;
+		  tm = otm;
+		  break;
+		}
+	      if ((ot += dt) == t)
+		break;  /* Avoid a redundant probe.  */
+	    }
+	}
+    }
+
+
+#if LEAP_SECONDS_POSSIBLE
+  if (sec_requested != tm.tm_sec)
+    {
+      /* Adjust time to reflect the tm_sec requested, not the normalized value.
+	 Also, repair any damage from a false match due to a leap second.  */
+      t += sec_requested - sec + (sec == 0 && tm.tm_sec == 60);
+    }
+#endif
+
+  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)
+    {
+      /* time_t isn't large enough to rule out overflows in ydhms_tm_diff,
+	 so check for major overflows.  A gross check suffices,
+	 since if t has overflowed, it is off by a multiple of
+	 TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of
+	 the difference that is bounded by a small value.  */
+
+      double dyear = (double) year_requested + mon_years - tm.tm_year;
+      double dday = 366 * dyear + mday;
+      double dsec = 60 * (60 * (24 * dday + hour) + min) + sec_requested;
+
+      if (TIME_T_MAX / 3 - TIME_T_MIN / 3 < (dsec < 0 ? - dsec : dsec))
+	return -1;
+    }
+
+  *tp = tm;
+#ifdef __KERNEL__
+  printk(KERN_ERR "udf: udf_converttime() returning %ld\n", t);
+#endif
+  return t;
+}
+#endif
+
+#ifdef INCLUDE_PRINT_KTM
+static void
+print_ktm (struct ktm *tp)
+{
+#ifdef __KERNEL__
+  printk(KERN_DEBUG  
+#else
+  printf(
+#endif
+	"%04d-%02d-%02d %02d:%02d:%02d isdst %d",
+	  tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,
+	  tp->tm_hour, tp->tm_min, tp->tm_sec, tp->tm_isdst);
+}
+#endif
+
+/* EOF */
diff -u --recursive --new-file v2.1.129/linux/fs/udf/unicode.c linux/fs/udf/unicode.c
--- v2.1.129/linux/fs/udf/unicode.c	Wed Dec 31 19:00:00 1969
+++ linux/fs/udf/unicode.c	Sun Nov 29 14:45:29 1998
@@ -0,0 +1,230 @@
+/*
+ * unicode.c
+ *
+ * PURPOSE
+ *	Routines for converting between UTF-8 and OSTA Compressed Unicode.
+ *
+ * DESCRIPTION
+ *	OSTA Compressed Unicode is explained in the OSTA UDF specification.
+ *		http://www.osta.org/
+ *	UTF-8 is explained in the IETF RFC XXXX.
+ *		ftp://ftp.internic.net/rfc/rfcxxxx.txt
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team's mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ */
+
+#include <linux/udf_fs.h>
+
+#ifdef __KERNEL__
+#include <linux/kernel.h>
+#include <linux/string.h>	/* for memset */
+#else
+#include <string.h>
+#endif
+
+/*
+ * udf_build_ustr
+ */
+int udf_build_ustr(struct ustr *dest, dstring *ptr, int size)
+{
+    int usesize;
+
+    if ( (!dest) || (!ptr) || (!size) )
+	return -1;
+
+    memset(dest, 0, sizeof(struct ustr));
+    usesize= (size > UDF_NAME_LEN) ? UDF_NAME_LEN : size;
+    dest->u_cmpID=ptr[0];
+    dest->u_len=ptr[size-1];
+    memcpy(dest->u_name, ptr+1, usesize-1);
+    return 0;
+}
+
+/*
+ * udf_build_ustr_exact
+ */
+int udf_build_ustr_exact(struct ustr *dest, dstring *ptr, int exactsize)
+{
+    if ( (!dest) || (!ptr) || (!exactsize) )
+	return -1;
+
+    memset(dest, 0, sizeof(struct ustr));
+    dest->u_cmpID=ptr[0];
+    dest->u_len=exactsize;
+    memcpy(dest->u_name, ptr+1, exactsize-1);
+    return 0;
+}
+
+/*
+ * udf_ocu_to_udf8
+ *
+ * PURPOSE
+ *	Convert OSTA Compressed Unicode to the UTF-8 equivalent.
+ *
+ * DESCRIPTION
+ *	This routine is only called by udf_filldir().
+ *
+ * PRE-CONDITIONS
+ *	utf			Pointer to UTF-8 output buffer.
+ *	ocu			Pointer to OSTA Compressed Unicode input buffer
+ *				of size UDF_NAME_LEN bytes.
+ * 				both of type "struct ustr *"
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	November 12, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_CS0toUTF8(struct ustr *utf_o, struct ustr *ocu_i)
+{
+	char *ocu;
+	unsigned c, cmp_id, ocu_len;
+	int i;
+
+	ocu=ocu_i->u_name;
+
+	ocu_len = ocu_i->u_len;
+	cmp_id = ocu_i->u_cmpID;
+	utf_o->u_len=0;
+
+	if ((cmp_id != 8) && (cmp_id != 16)) {
+#ifdef __KERNEL__
+		printk(KERN_ERR "udf: unknown compression code (%d)\n", cmp_id);
+#endif
+		return -1;
+	}
+
+	for (i = 0; (i < ocu_len) && (utf_o->u_len < UDF_NAME_LEN) ;) {
+
+		/* Expand OSTA compressed Unicode to Unicode */
+		c = ocu[i++];
+		if (cmp_id == 16)
+			c = (c << 8 ) | ocu[i++];
+
+		/* Compress Unicode to UTF-8 */
+		if (c < 0x80U)
+			utf_o->u_name[utf_o->u_len++] = (char)c;
+		else if (c < 0x800U) {
+			utf_o->u_name[utf_o->u_len++] = (char)(0xc0 | (c >> 6));
+			utf_o->u_name[utf_o->u_len++] = (char)(0x80 | (c & 0x3f));
+		} else {
+			utf_o->u_name[utf_o->u_len++] = (char)(0xc0 | (c >> 12));
+			utf_o->u_name[utf_o->u_len++] = (char)(0x80 | ((c >> 6) & 0x3f));
+			utf_o->u_name[utf_o->u_len++] = (char)(0x80 | (c & 0x3f));
+		}
+	}
+	utf_o->u_cmpID=8;
+	utf_o->u_hash=0L;
+	utf_o->padding=0;
+
+	return 0;
+}
+
+/*
+ *
+ * udf_utf8_to_ocu
+ *
+ * PURPOSE
+ *	Convert UTF-8 to the OSTA Compressed Unicode equivalent.
+ *
+ * DESCRIPTION
+ *	This routine is only called by udf_lookup().
+ *
+ * PRE-CONDITIONS
+ *	ocu			Pointer to OSTA Compressed Unicode output
+ *				buffer of size UDF_NAME_LEN bytes.
+ *	utf			Pointer to UTF-8 input buffer.
+ *	utf_len			Length of UTF-8 input buffer in bytes.
+ *
+ * POST-CONDITIONS
+ *	<return>		Zero on success.
+ *
+ * HISTORY
+ *	November 12, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ */
+int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)
+{
+	unsigned c, i, max_val, utf_char;
+	int utf_cnt;
+	int u_len = 0;
+
+	memset(ocu, 0, sizeof(dstring) * length);
+	ocu[0] = 8;
+	max_val = 0xffU;
+
+try_again:
+	utf_char = 0U;
+	utf_cnt = 0U;
+	for (i = 0U; i < utf->u_len; i++) {
+		c = (unsigned)utf->u_name[i];
+
+		/* Complete a multi-byte UTF-8 character */
+		if (utf_cnt) {
+			utf_char = (utf_char << 6) | (c & 0x3fU);
+			if (--utf_cnt)
+				continue;
+		} else {
+			/* Check for a multi-byte UTF-8 character */
+			if (c & 0x80U) {
+				/* Start a multi-byte UTF-8 character */
+				if ((c & 0xe0U) == 0xc0U) {
+					utf_char = c & 0x1fU;
+					utf_cnt = 1;
+				} else if ((c & 0xf0U) == 0xe0U) {
+					utf_char = c & 0x0fU;
+					utf_cnt = 2;
+				} else if ((c & 0xf8U) == 0xf0U) {
+					utf_char = c & 0x07U;
+					utf_cnt = 3;
+				} else if ((c & 0xfcU) == 0xf8U) {
+					utf_char = c & 0x03U;
+					utf_cnt = 4;
+				} else if ((c & 0xfeU) == 0xfcU) {
+					utf_char = c & 0x01U;
+					utf_cnt = 5;
+				} else
+					goto error_out;
+				continue;
+			} else
+				/* Single byte UTF-8 character (most common) */
+				utf_char = c;
+		}
+
+		/* Choose no compression if necessary */
+		if (utf_char > max_val) {
+			if ( 0xffU == max_val ) {
+				max_val = 0xffffU;
+				ocu[0] = (Uint8)0x10U;
+				goto try_again;
+			}
+			goto error_out;
+		}
+
+		if (max_val == 0xffffU)
+			ocu[++u_len] = (Uint8)(utf_char >> 8);
+		ocu[++u_len] = (Uint8)(utf_char & 0xffU);
+	}
+
+	if (utf_cnt) {
+error_out:
+#ifdef __KERNEL__
+		printk(KERN_ERR "udf: bad UTF-8 character\n");
+#endif
+		return -1;
+	}
+
+	ocu[length - 1] = (Uint8)u_len;
+	return 0;
+}
diff -u --recursive --new-file v2.1.129/linux/include/config/udf/fs/module.h linux/include/config/udf/fs/module.h
--- v2.1.129/linux/include/config/udf/fs/module.h	Wed Dec 31 19:00:00 1969
+++ linux/include/config/udf/fs/module.h	Sun Nov 29 16:52:48 1998
@@ -0,0 +1 @@
+#define CONFIG_UDF_FS_MODULE 1
diff -u --recursive --new-file v2.1.129/linux/include/config/udf/fs.h linux/include/config/udf/fs.h
--- v2.1.129/linux/include/config/udf/fs.h	Wed Dec 31 19:00:00 1969
+++ linux/include/config/udf/fs.h	Sun Nov 29 16:52:48 1998
@@ -0,0 +1 @@
+#undef  CONFIG_UDF_FS
diff -u --recursive --new-file v2.1.129/linux/include/linux/udf_167.h linux/include/linux/udf_167.h
--- v2.1.129/linux/include/linux/udf_167.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/udf_167.h	Sun Nov 29 14:45:29 1998
@@ -0,0 +1,875 @@
+#if !defined(_LINUX_UDF_167_H)
+#define _LINUX_UDF_167_H
+/*
+ * udf_167.h
+ *
+ * DESCRIPTION
+ *	Definitions from the ECMA 167 standard.
+ *	http://www.ecma.ch/
+ *
+ *	These abbreviations are used to keep the symbols short:
+ *		Alloc	Allocation
+ *		App	Application
+ *		Attr	Attribute
+ *		Char	Characters
+ *		Desc	Descriptor
+ *		Descs	Descriptors
+ *		Ext	Extent
+ *		Ident	Identifier
+ *		Imp	Implementation
+ *		Lvl	Level
+ *		Max	Maximum
+ *		Num	Number
+ *		Ptr	Pointer
+ *		Seq	Sequence
+ *		Std	Standard
+ *		Struct	Structure
+ *		Vol	Volume
+ *	The symbols are otherwise identical to the standard, and the
+ *	sections of the standard to refer to are indicated.
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ *
+ * HISTORY
+ *	July 12, 1997 - Andrew E. Mileski
+ *	Adapted from the ECMA-167 standard.
+ *
+ * 10/2/98 dgb	Adaptation
+ * 10/4/98 	Changes by HJA Sandkuyl
+ * 10/7/98	Changed FILE_EXISTENCE to FILE_HIDDEN, per UDF 2.0 spec
+ * 11/26/98	Modifed some entries for UDF 1.5/2.0
+ * 11/26/98 bf  Fixed typos, non-linux types, more structures
+ */
+
+#ifdef __linux__
+#define Uint8	__u8
+#define Uint16	__u16
+#define Uint32	__u32
+#define Uint64	__u64
+typedef __u8	dstring;
+#else
+#define Uint8	unsigned char
+#define Uint16	unsigned short
+#define Uint32	unsigned long
+#define Uint64	unsigned long long
+typedef char	dstring;
+#endif
+
+
+/* make sure all structures are packed! */
+#ifdef __linux__
+#pragma pack(1)
+#endif /*__linux__ */
+
+/* CS0 Charspec (ECMA 167 1/7.2.1) */
+typedef struct {
+	Uint8 charSetType;
+	Uint8 charSetInfo[63];
+} charspec;
+
+/* Timestamp (ECMA 167 1/7.3) */
+typedef struct {
+	Uint16 typeAndTimezone;
+	Uint16 year;
+	Uint8 month;
+	Uint8 day;
+	Uint8 hour;
+	Uint8 minute;
+	Uint8 second;
+	Uint8 centiseconds;
+	Uint8 hundredsOfMicroseconds;
+	Uint8 microseconds;
+} timestamp;
+
+/* Timestamp types (ECMA 167 1/7.3.1) */
+#define TIMESTAMP_TYPE_CUT		0x0000U
+#define TIMESTAMP_TYPE_LOCAL		0x0001U
+#define TIMESTAMP_TYPE_AGREEMENT	0x0002U
+
+/* Entity Identifier (ECMA 167 1/7.4) */
+typedef struct {
+	Uint8 flags;
+	Uint8 ident[23];
+	Uint8 identSuffix[8];
+} EntityID;
+#define regid EntityID
+
+/* Entity identifier flags (ECMA 167 1/7.4.1) */
+#define ENTITYID_FLAGS_DIRTY		0x01U
+#define ENTITYID_FLAGS_PROTECTED	0x02U
+
+/* Volume Structure Descriptor (ECMA 167 2/9.1) */
+#define STD_ID_LEN	5
+struct VolStructDesc {
+	Uint8 structType;
+	Uint8 stdIdent[STD_ID_LEN];
+	Uint8 structVersion;
+	Uint8 structData[2041];
+};
+
+/* Std structure identifiers (ECMA 167 2/9.1.2) */
+#define STD_ID_BEA01	"BEA01"
+#define STD_ID_BOOT2	"BOOT2"
+#define STD_ID_CD001	"CD001"
+#define STD_ID_CDW02	"CDW02"
+#define STD_ID_NSR02	"NSR02"
+#define STD_ID_NSR03	"NSR03"
+#define STD_ID_TEA01	"TEA01"
+
+/* Beginning Extended Area Descriptor (ECMA 167 2/9.2) */
+struct BeginningExtendedAreaDesc {
+	Uint8 structType;
+	Uint8 stdIdent[STD_ID_LEN];
+	Uint8 structVersion;
+	Uint8 structData[2041];
+};
+
+/* Terminating Extended Area Descriptor (ECMA 167 2/9.3) */
+struct TerminatingExtendedAreaDesc {
+	Uint8 structType;
+	Uint8 stdIdent[STD_ID_LEN];
+	Uint8 structVersion;
+	Uint8 structData[2041];
+};
+
+/* Boot Descriptor (ECMA 167 2/9.4) */
+struct BootDesc {
+	Uint8 structType;
+	Uint8 stdIdent[STD_ID_LEN];
+	Uint8 structVersion;
+	Uint8 reserved1;
+	EntityID architectureType;
+	EntityID bootIdent;
+	Uint32 bootExtLocation;
+	Uint32 bootExtLength;
+	Uint64 loadAddress;
+	Uint64 startAddress;
+	timestamp descCreationDateAndTime;
+	Uint16 flags;
+	Uint8 reserved2[32];
+	Uint8 bootUse[1906];
+};
+
+/* Boot flags (ECMA 167 2/9.4.12) */
+#define BOOT_FLAGS_ERASE	1
+
+/* Extent Descriptor (ECMA 167 3/7.1) */
+typedef struct {
+	Uint32 extLength;
+	Uint32 extLocation;
+} extent_ad;
+
+/* Descriptor Tag (ECMA 167 3/7.2) */
+typedef struct {
+	Uint16 tagIdent;
+	Uint16 descVersion;
+	Uint8 tagChecksum;
+	Uint8 reserved;
+	Uint16 tagSerialNum;
+	Uint16 descCRC;
+	Uint16 descCRCLength;
+	Uint32 tagLocation;
+} tag;
+
+/* Tag Identifiers (ECMA 167 3/7.2.1) */
+#define TID_UNUSED_DESC			0x0000U
+#define TID_PRIMARY_VOL_DESC		0x0001U
+#define TID_ANCHOR_VOL_DESC_PTR		0x0002U
+#define TID_VOL_DESC_PTR		0x0003U
+#define TID_IMP_USE_VOL_DESC		0x0004U
+#define TID_PARTITION_DESC		0x0005U
+#define TID_LOGICAL_VOL_DESC		0x0006U
+#define TID_UNALLOC_SPACE_DESC		0x0007U
+#define TID_TERMINATING_DESC		0x0008U
+#define TID_LOGICAL_VOL_INTEGRITY_DESC	0x0009U
+
+/* Tag Identifiers (ECMA 167 4/7.2.1) */
+#define TID_FILE_SET_DESC		0x0100U
+#define TID_FILE_IDENT_DESC		0x0101U
+#define TID_ALLOC_EXTENT_DESC		0x0102U
+#define TID_INDIRECT_ENTRY		0x0103U
+#define TID_TERMINAL_ENTRY		0x0104U
+#define TID_FILE_ENTRY			0x0105U
+#define TID_EXTENDED_ATTRE_HEADER_DESC	0x0106U
+#define TID_UNALLOCATED_SPACE_ENTRY	0x0107U
+#define TID_SPACE_BITMAP_DESC		0x0108U
+#define TID_PARTITION_INTEGRITY_ENTRY	0x0109U
+
+/* NSR Descriptor (ECMA 167 3/9.1) */
+struct NSRDesc {
+	Uint8 structType;
+	Uint8 stdIdent[STD_ID_LEN];
+	Uint8 structVersion;
+	Uint8 reserved;
+	Uint8 structData[2040];
+};
+	
+/* Primary Volume Descriptor (ECMA 167 3/10.1) */
+struct PrimaryVolDesc {
+	tag descTag;
+	Uint32 volDescSeqNum;
+	Uint32 primaryVolDescNum;
+	dstring volIdent[32];
+	Uint16 volSeqNum;
+	Uint16 maxVolSeqNum;
+	Uint16 interchangeLvl;
+	Uint16 maxInterchangeLvl;
+	Uint32 charSetList;
+	Uint32 maxCharSetList;
+	dstring volSetIdent[128];
+	charspec descCharSet;
+	charspec explanatoryCharSet;
+	extent_ad volAbstract;
+	extent_ad volCopyrightNotice;
+	EntityID appIdent;
+	timestamp recordingDateAndTime;
+	EntityID impIdent;
+	Uint8 impUse[64];
+	Uint32 predecessorVolDescSeqLocation;
+	Uint16 flags;
+	Uint8 reserved[22];
+};
+
+/* Primary volume descriptor flags (ECMA 167 3/10.1.21) */
+#define VOL_SET_IDENT	1
+
+/* Anchor Volume Descriptor Pointer (ECMA 167 3/10.2) */
+struct AnchorVolDescPtr {
+	tag descTag;
+	extent_ad mainVolDescSeqExt;
+	extent_ad reserveVolDescSeqExt;
+	Uint8 reserved[480];
+};
+
+/* Volume Descriptor Pointer (ECMA 167 3/10.3) */
+struct VolDescPtr {
+	tag descTag;
+	Uint32 volDescSeqNum;
+	extent_ad nextVolDescSeqExt;
+	Uint8 reserved[484];
+};
+
+/* Implementation Use Volume Descriptor (ECMA 167 3/10.4) */
+struct ImpUseVolDesc {
+	tag descTag;
+	Uint32 volDescSeqNum;
+	EntityID impIdent;
+	Uint8 impUse[460];
+};
+
+struct LogicalVolIntegrityDescImpUse
+{
+	EntityID	impIdent;
+	Uint32		numFiles;
+	Uint32		numDirs;
+	Uint16		minUDFReadRev;
+	Uint16		minUDFWriteRev;
+	Uint16		maxUDFWriteRev;
+};
+
+/* LVInformation may be present in ImpUseVolDesc.impUse */
+struct ImpUseVolDescImpUse
+{
+	charspec	LVICharset;
+	dstring		logicalVolIdent[128];
+	dstring		LVInfo1[36];
+	dstring		LVInfo2[36];
+	dstring		LVInfo3[36];
+	EntityID	impIdent;
+	Uint8		impUse[128];
+};
+
+/* Partition Descriptor (ECMA 167 3/10.5) */
+struct PartitionDesc {
+	tag descTag;
+	Uint32 volDescSeqNum;
+	Uint16 partitionFlags;
+	Uint16 partitionNumber;
+	EntityID partitionContents;
+	Uint8 partitionContentsUse[128];
+	Uint32 accessType;
+	Uint32 partitionStartingLocation;
+	Uint32 partitionLength;
+	EntityID impIdent;
+	Uint8 impUse[128];
+	Uint8 reserved[156];
+};
+
+/* Partition Flags (ECMA 167 3/10.5.3) */
+#define PARTITION_FLAGS_ALLOC	1
+
+/* Partition Contents (ECMA 167 3/10.5.5) */
+#define PARTITION_CONTENTS_FDC01	"+FDC01"
+#define PARTITION_CONTENTS_CD001	"+CD001"
+#define PARTITION_CONTENTS_CDW02	"+CDW02"
+#define PARTITION_CONTENTS_NSR02	"+NSR02"
+#define PARTITION_CONTENTS_NSR03	"+NSR03"
+
+/* Partition Access Types (ECMA 167 3/10.5.7) */
+#define PARTITION_ACCESS_NONE	0
+#define PARTITION_ACCESS_R	1
+#define PARTITION_ACCESS_WO	2
+#define PARTITION_ACCESS_RW	3
+#define PARTITION_ACCESS_OW	4
+
+/* Logical Volume Descriptor (ECMA 167 3/10.6) */
+struct LogicalVolDesc {
+	tag descTag;
+	Uint32 volDescSeqNum;
+	charspec descCharSet;
+	dstring logicalVolIdent[128];
+	Uint32 logicalBlockSize;
+	EntityID domainIdent;
+	Uint8 logicalVolContentsUse[16]; /* used to find fileset */
+	Uint32 mapTableLength;
+	Uint32 numPartitionMaps;
+	EntityID impIdent;
+	Uint8 impUse[128];
+	extent_ad integritySeqExt;
+	Uint8 partitionMaps[0];
+};
+
+/* Generic Partition Map (ECMA 167 3/10.7.1) */
+struct GenericPartitionMap {
+	Uint8 partitionMapType;
+	Uint8 partitionMapLength;
+	Uint8 partitionMapping[0];
+};
+
+/* Partition Map Type (ECMA 167 3/10.7.1.1) */
+#define PARTITION_MAP_TYPE_NONE		0
+#define PARTITION_MAP_TYPE_1		1
+#define PARTITION_MAP_TYPE_2		2
+
+/* Type 1 Partition Map (ECMA 167 3/10.7.2) */
+struct GenericPartitionMap1 {
+	Uint8 partitionMapType;
+	Uint8 partitionMapLength;
+	Uint16 volSeqNum;
+	Uint16 partitionNum;
+};
+
+/* Type 2 Partition Map (ECMA 167 3/10.7.3) */
+struct GenericPartitionMap2 {
+	Uint8 partitionMapType; /* 2 */
+	Uint8 partitionMapLength; 
+	Uint8 partitionIdent[62];
+};
+
+/* A Type 2 Partition Map */
+struct VirtualPartitionMap
+{
+	Uint8		partitionMapType;	/* 2 */
+	Uint8		partitionMapLength;	/* 64 */
+	Uint8		reserved1[2];		/* #00 */
+	EntityID	partIdent;
+	Uint16		volSeqNum;
+	Uint16		partitionNum;
+	Uint8		reserved2[24];		/* #00 */
+};
+
+/* A Type 2 Partition Map */
+struct SparablePartitionMap
+{
+	Uint8		partitionMapType;	/* 2 */
+	Uint8		partitionMapLength;	/* 64 */
+	Uint8		reserved1[2];		/* #00 */
+	EntityID	partIdent;		/* Flags = 0 */
+						/* Id = UDF_ID_SPARABLE */
+						/* IdSuf = 2.1.5.3 */
+	Uint16		volSeqNum;
+	Uint16		partitioNum;
+	Uint16		packetLength;		/* 32 */
+	Uint8		numSparingTables;
+	Uint8		reserved2[1];		/* #00 */
+	Uint32		sizeSparingTable;
+	Uint32		locSparingTable[0];
+	Uint8		pad[0];
+};
+ 
+/* Unallocated Space Descriptor (ECMA 167 3/10.8) */
+struct UnallocatedSpaceDesc {
+	tag descTag;
+	Uint32 volDescSeqNum;
+	Uint32 numAllocDescs;
+	extent_ad allocDescs[0];
+};
+
+/* Terminating Descriptor (ECMA 3/10.9) */
+struct TerminatingDesc {
+	tag descTag;
+	Uint8 reserved[496];
+};
+
+/* Logical Volume Integrity Descriptor (ECMA 167 3/10.10) */
+struct LogicalVolIntegrityDesc {
+	tag descTag;
+	timestamp recordingDateAndTime;
+	Uint32 integrityType;
+	extent_ad nextIntegrityExt;
+	Uint8 logicalVolContentsUse[32];
+	Uint32 numOfPartitions;
+	Uint32 lengthOfImpUse;
+	Uint32 freeSpaceTable[0];
+	Uint32 sizeTable[0];
+	Uint8 impUse[0];
+	/*struct LogicalVolIntegrityDescImpUse impUse;*/
+};
+
+/* virtual allocation, see UDF 2.0 2.2.10 */
+struct VirtualAllocationTable {
+	Uint16 lengthHeader;
+	Uint16 lengthImpUse;
+	dstring logicalVolIdent[128];
+	Uint32	previousVatICBLoc;
+	Uint32  numFIDSFiles;
+	Uint32  numFIDSDirectories; /* non-parent */
+	Uint16  minReadRevision;
+	Uint16	minWriteRevision;
+	Uint16  maxWriteRevision;
+	Uint16  reserved;
+	Uint8	impUse[0];
+	Uint32  vatEntry[0];
+};
+
+/* sparing maps, see UDF 2.0 2.2.11 */
+typedef struct {
+	Uint32  origLocation;
+	Uint32  mappedLocation;
+} SparingEntry;
+
+/* sparing maps, see UDF 2.0 2.2.11 */
+struct SparingTable {
+	Uint16  tag;
+	EntityID sparingIdent; /* *UDF Sparing Table */
+	Uint16   reallocationTableLen;
+	Uint16   reserved;
+	Uint32   sequenceNum;
+	SparingEntry mapEntry[0];
+};
+
+/* Integrity Types (ECMA 167 3/10.10.3) */
+#define INTEGRITY_TYPE_OPEN	0
+#define INTEGRITY_TYPE_CLOSE	1
+
+/* Recorded Address (ECMA 167 4/7.1) */
+typedef struct {
+	Uint32 logicalBlockNum;
+	Uint16 partitionReferenceNum;
+} lb_addr;
+
+/* Extent interpretation (ECMA 167 4/14.14.1.1) */
+#define EXTENT_RECORDED_ALLOCATED               0x00
+#define EXTENT_RECORDED_NOT_ALLOCATED           0x01
+#define EXTENT_NOT_RECORDED_NOT_ALLOCATED       0x02
+#define EXTENT_NEXT_EXTENT_ALLOCDECS            0x03
+
+/* Long Allocation Descriptor (ECMA 167 4/14.14.2) */
+typedef struct {
+	Uint32 extLength;
+	lb_addr extLocation;
+	Uint8 impUse[6];
+} long_ad;
+	/* upper 2 bits of extLength indicate type */
+
+/* the impUse of long_ad used with FileIdent */
+struct UniqueID {
+	Uint16 reserved;
+	Uint32 uniqueIdent;
+};
+/* the impUse of long_ad used in AllocDescs */
+struct ADImpUse {
+	Uint16 flags;
+	Uint8  impUse[4];
+};
+
+#define UDF_EXTENT_LENGTH_MASK		0x3FFFFFFF
+#define UDF_EXTENT_FLAG_MASK		0xc0000000
+#define UDF_EXTENT_FLAG_ERASED		0x40000000
+
+/* File Set Descriptor (ECMA 167 4/14.1) */
+struct FileSetDesc {
+	tag descTag;
+	timestamp recordingDateAndTime;
+	Uint16 interchangeLvl;
+	Uint16 maxInterchangeLvl;
+	Uint32 charSetList;
+	Uint32 maxCharSetList;
+	Uint32 fileSetNum;
+	Uint32 fileSetDescNum;
+	charspec logicalVolIdentCharSet;
+	dstring logicalVolIdent[128];
+	charspec fileSetCharSet;
+	dstring fileSetIdent[32];
+	dstring copyrightFileIdent[32];
+	dstring abstractFileIdent[32];
+	long_ad rootDirectoryICB;
+	EntityID domainIdent;
+	long_ad nextExt;
+	long_ad streamDirectoryICB;
+	Uint8 reserved[32];
+};
+
+/* Short Allocation Descriptor (ECMA 167 4/14.14.1) */
+typedef struct {
+	Uint32 extLength;
+	Uint32 extPosition;
+} short_ad;
+
+/* Partition Header Descriptor (ECMA 167 4/14.3) */
+struct PartitionHeaderDesc {
+	short_ad unallocatedSpaceTable;
+	short_ad unallocatedSpaceBitmap;
+	short_ad partitionIntegrityTable;
+	short_ad freedSpaceTable;
+	short_ad freedSpaceBitmap;
+	Uint8 reserved[88];
+};
+
+/* File Identifier Descriptor (ECMA 167 4/14.4) */
+struct FileIdentDesc {
+	tag descTag;
+	Uint16 fileVersionNum; /* 1 */
+	Uint8 fileCharacteristics;
+	Uint8 lengthFileIdent;
+	long_ad icb;
+	Uint16 lengthOfImpUse;
+	Uint8 impUse[0];
+	char fileIdent[0];
+	Uint8 padding[0];
+};
+
+/* File Characteristics (ECMA 167 4/14.4.3) */
+#define FILE_HIDDEN	1
+#define FILE_DIRECTORY	2
+#define FILE_DELETED	4
+#define FILE_PARENT	8
+#define FILE_METADATA	0x10 /* UDF 2.0 */
+
+/* Allocation Ext Descriptor (ECMA 167 4/14.5) */
+struct AllocExtDesc {
+	tag descTag;
+	Uint32 previousAllocExtLocation;
+	Uint32 lengthAllocDescription;
+};
+
+/* ICB Tag (ECMA 167 4/14.6) */
+typedef struct {
+	Uint32 priorRecordedNumDirectEntries;
+	Uint16 strategyType;
+	Uint16 strategyParameter;
+	Uint16 numEntries;
+	Uint8 reserved;
+	Uint8 fileType;
+	lb_addr parentICBLocation;
+	Uint16 flags;
+} icbtag;
+
+/* ICB File Type (ECMA 167 4/14.6.6) */
+#define FILE_TYPE_NONE		0x00U
+#define FILE_TYPE_UNALLOC	0x01U
+#define FILE_TYPE_INTEGRITY	0x02U
+#define FILE_TYPE_INDIRECT	0x03U
+#define FILE_TYPE_DIRECTORY	0x04U
+#define FILE_TYPE_REGULAR	0x05U
+#define FILE_TYPE_BLOCK		0x06U
+#define FILE_TYPE_CHAR		0x07U
+#define FILE_TYPE_EXTENDED	0x08U
+#define FILE_TYPE_FIFO		0x09U
+#define FILE_TYPE_SOCKET	0x0aU
+#define FILE_TYPE_TERMINAL	0x0bU
+#define FILE_TYPE_SYMLINK	0x0cU
+#define FILE_TYPE_STREAMDIR	0x0dU /* UDF 2.0 */
+/* VAT added for CD-R, see UDF 2.0 2.2.10 */
+#define FILE_TYPE_VAT		0xf8U
+
+/* ICB Flags (ECMA 167 4/14.6.8) */
+#define ICB_FLAG_ALLOC_MASK	0x0007U
+#define ICB_FLAG_SORTED		0x0008U
+#define ICB_FLAG_NONRELOCATABLE	0x0010U
+#define ICB_FLAG_ARCHIVE	0x0020U
+#define ICB_FLAG_SETUID		0x0040U
+#define ICB_FLAG_SETGID		0x0080U
+#define ICB_FLAG_STICKY		0x0100U
+#define ICB_FLAG_CONTIGUOUS	0x0200U
+#define ICB_FLAG_SYSTEM		0x0400U
+#define ICB_FLAG_TRANSFORMED	0x0800U
+#define ICB_FLAG_MULTIVERSIONS	0x1000U
+
+/* ICB Flags Allocation type(ECMA 167 4/14.6.8) */
+#define ICB_FLAG_AD_SHORT	0
+#define ICB_FLAG_AD_LONG	1
+#define ICB_FLAG_AD_EXTENDED	2
+#define ICB_FLAG_AD_IN_ICB	3
+
+/* Indirect Entry (ECMA 167 4/14.7) */
+struct IndirectEntry {
+	tag descTag;
+	icbtag icbTag;
+	long_ad indirectICB;
+};
+
+/* Terminal Entry (ECMA 167 4/14.8) */
+struct TerminalEntry {
+	tag descTag;
+	icbtag icbTag;
+};
+
+/* File Entry (ECMA 167 4/14.9) */
+struct FileEntry {
+	tag descTag;
+	icbtag icbTag;
+	Uint32 uid;
+	Uint32 gid;
+	Uint32 permissions;
+	Uint16 fileLinkCount;
+	Uint8 recordFormat;
+	Uint8 recordDisplayAttr;
+	Uint32 recordLength;
+	Uint64 informationLength;
+	Uint64 logicalBlocksRecorded;
+	timestamp accessTime;
+	timestamp modificationTime;
+	timestamp attrTime;
+	Uint32 checkpoint;
+	long_ad extendedAttrICB;
+	EntityID impIdent;
+	Uint64 uniqueID; /* 0= root, 16- (2^32-1) */
+	Uint32 lengthExtendedAttr;
+	Uint32 lengthAllocDescs;
+	Uint8 extendedAttr[0];
+	Uint8 allocDescs[0];
+};
+
+/* File Permissions (ECMA 167 4/14.9.5) */
+#define PERM_O_EXEC	0x00000001U
+#define PERM_O_WRITE	0x00000002U
+#define PERM_O_READ	0x00000004U
+#define PERM_O_CHATTR	0x00000008U
+#define PERM_O_DELETE	0x00000010U
+#define PERM_G_EXEC	0x00000020U
+#define PERM_G_WRITE	0x00000040U
+#define PERM_G_READ	0x00000080U
+#define PERM_G_CHATTR	0x00000100U
+#define PERM_G_DELETE	0x00000200U
+#define PERM_U_EXEC	0x00000400U
+#define PERM_U_WRITE	0x00000800U
+#define PERM_U_READ	0x00001000U
+#define PERM_U_CHATTR	0x00002000U
+#define PERM_U_DELETE	0x00004000U
+
+/* File Record Format (ECMA 167 4/14.9.7) */
+#define RECORD_FMT_NONE			0
+#define RECORD_FMT_FIXED_PAD		1
+#define RECORD_FMT_FIXED		2
+#define RECORD_FMT_VARIABLE8		3
+#define RECORD_FMT_VARIABLE16		4
+#define RECORD_FMT_VARIABLE16_MSB	5
+#define RECORD_FMT_VARIABLE32		6
+#define RECORD_FMT_PRINT		7
+#define RECORD_FMT_LF			8
+#define RECORD_FMT_CR			9
+#define RECORD_FMT_CRLF			10
+#define RECORD_FMT_LFCR			10
+
+/* Extended Attribute Header Descriptor (ECMA 167 4/14.10.1) */
+struct ExtendedAttrHeaderDesc {
+	tag descTag;
+	Uint32 impAttrLocation;
+	Uint32 appAttrLocation;
+};
+
+/* Generic Attribute Format (ECMA 4/14.10.2) */
+struct GenericAttrFormat {
+	Uint32 attrType;
+	Uint8 attrSubtype;
+	Uint8 reserved[3];
+	Uint32 attrLength;
+	Uint8 attrData[0];
+};
+
+/* Character Set Attribute Format (ECMA 4/14.10.3) */
+struct CharSetAttrFormat {
+	Uint32 attrType;
+	Uint8 attrSubtype;
+	Uint8 reserved[3];
+	Uint32 attrLength;
+	Uint32 escapeSeqLength;
+	Uint8 charSetType;
+	Uint8 escapeSeq[0];
+};
+
+/* Alternate Permissions (ECMA 167 4/14.10.4) */
+struct AlternatePermissionsExtendedAttr {
+	Uint32 attrType;
+	Uint8 attrSubtype;
+	Uint8 reserved[3];
+	Uint32 attrLength;
+	Uint16 ownerIdent;
+	Uint16 groupIdent;
+	Uint16 permission;
+};
+
+/* File Times Extended Attribute (ECMA 167 4/14.10.5) */
+struct FileTimesExtendedAttr {
+	Uint32 attrType;
+	Uint8 attrSubtype;
+	Uint8 reserved[3];
+	Uint32 attrLength;
+	Uint32 dataLength;
+	Uint32 fileTimeExistence;
+	Uint8 fileTimes;
+};
+
+/* FileTimeExistence (ECMA 167 4/14.10.5.6) */
+#define FTE_CREATION	0
+#define FTE_DELETION	2
+#define FTE_EFFECTIVE	3
+#define FTE_BACKUP	5
+
+/* Information Times Extended Attribute (ECMA 167 4/14.10.6) */
+struct InfoTimesExtendedAttr {
+	Uint32 attrType;
+	Uint8 attrSubtype;
+	Uint8 reserved[3];
+	Uint32 attrLength;
+	Uint32 dataLength;
+	Uint32 infoTimeExistence;
+	Uint8 infoTimes[0];
+};
+
+/* Device Specification Extended Attribute (ECMA 167 4/14.10.7) */
+struct DeviceSpecificationExtendedAttr {
+	Uint32 attrType;
+	Uint8 attrSubtype;
+	Uint8 reserved[3];
+	Uint32 attrLength;
+	Uint32 impUseLength;
+	Uint32 majorDeviceIdent;
+	Uint32 minorDeviceIdent;
+	Uint8 impUse[0];
+};
+
+/* Implementation Use Extended Attr (ECMA 167 4/14.10.8) */
+struct ImpUseExtendedAttr {
+	Uint32 attrType;
+	Uint8 attrSubtype;
+	Uint8 reserved[3];
+	Uint32 attrLength;
+	Uint32 impUseLength;
+	EntityID impIdent;
+	Uint8 impUse[0];
+};
+
+/* DVD Copyright Management Info, see UDF 2.0 3.3.4.5.1.2 */
+/* when ImpUseExtendedAttr.impIdent= "*UDF DVD CGMS Info" */
+struct DVDCopyrightImpUse {
+	Uint16 headerChecksum;
+	Uint8  CGMSInfo;
+	Uint8  dataType;
+	Uint8  protectionSystemInfo[4];
+};
+
+/* Application Use Extended Attribute (ECMA 167 4/14.10.9) */
+struct AppUseExtendedAttr {
+	Uint32 attrType;
+	Uint8 attrSubtype;
+	Uint8 reserved[3];
+	Uint32 attrLength;
+	Uint32 appUseLength;
+	EntityID appIdent;
+	Uint8 appUse[0];
+};
+
+/* Unallocated Space Entry (ECMA 167 4/14.11) */
+struct UnallocatedSpaceEntry {
+	tag descTag;
+	icbtag icbTag;
+	Uint32 lengthAllocDescs;
+	Uint8 allocDescs[0];
+};
+
+/* Space Bitmap Descriptor (ECMA 167 4/14.12) */
+struct SpaceBitmapDesc {
+	tag descTag;
+	Uint32 numOfBits;
+	Uint32 numOfBytes;
+	Uint8 bitmap[0];
+};
+
+/* Partition Integrity Entry (ECMA 167 4/14.13) */
+struct PartitionIntegrityEntry {
+	tag descTag;
+	icbtag icbTag;
+	timestamp recordingDateAndTime;
+	Uint8 integrityType;
+	Uint8 reserved[175];
+	EntityID impIdent;
+	Uint8 impUse[256];
+};
+
+/* Extended Allocation Descriptor (ECMA 167 4/14.14.3) */
+typedef struct { /* ECMA 167 4/14.14.3 */
+	Uint32 extLength;
+	Uint32 recordedLength;
+	Uint32 informationLength;
+	lb_addr extLocation;
+} ext_ad;
+
+/* Logical Volume Header Descriptor (ECMA 167 4/14.5) */
+struct LogicalVolHeaderDesc {
+	Uint64 uniqueId;
+	Uint8 reserved[24];
+};
+
+/* Path Component (ECMA 167 4/14.16.1) */
+struct PathComponent {
+	Uint8 componentType;
+	Uint8 lengthComponentIdent;
+	Uint16 componentFileVersionNum;
+	dstring componentIdent[0];
+};
+
+/* File Entry (ECMA 167 4/14.17) */
+struct ExtendedFileEntry {
+	tag		descTag;
+	icbtag		icbTag;
+	Uint32		uid;
+	Uint32		gid;
+	Uint32		permissions;
+	Uint16		fileLinkCount;
+	Uint8		recordFormat;
+	Uint8		recordDisplayAttr;
+	Uint32		recordLength;
+	Uint64		informationLength;
+	Uint64		objectSize;
+	Uint64		logicalBlocksRecorded;
+	timestamp	accessTime;
+	timestamp	modificationTime;
+	timestamp	createTime;
+	timestamp	attrTime;
+	Uint32		checkpoint;
+	Uint32		reserved;
+	long_ad		extendedAttrICB;
+	long_ad		streamDirectoryICB;
+	EntityID	impIdent;
+	Uint64		uniqueID;
+	Uint32		lengthExtendedAttr;
+	Uint32		lengthAllocDescs;
+	Uint8		extendedAttr[0];
+	Uint8		allocDescs[0];
+};
+#ifdef __linux__
+#pragma pack()
+#endif /*__linux__ */
+
+#endif /* !defined(_LINUX_UDF_167_H) */
diff -u --recursive --new-file v2.1.129/linux/include/linux/udf_fs.h linux/include/linux/udf_fs.h
--- v2.1.129/linux/include/linux/udf_fs.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/udf_fs.h	Sun Nov 29 14:48:04 1998
@@ -0,0 +1,195 @@
+#if !defined(_LINUX_UDF_FS_H)
+#define _LINUX_UDF_FS_H
+/*
+ * udf_fs.h
+ *
+ * PURPOSE
+ *	Global header file for OSTA-UDF(tm) filesystem.
+ *
+ * DESCRIPTION
+ *	This file is included by other header files, so keep it short.
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ *
+ * HISTORY
+ *	July 21, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ *
+ * 10/2/98 dgb	rearranged all headers
+ * 11/26/98 bf  added byte order macros
+ */
+
+#ifdef __linux__
+#include <linux/types.h>
+#include <config/udf/fs.h>
+#include <linux/udf_167.h>	/* ECMA 167 */
+#include <linux/udf_udf.h>	/* UDF 1.5  */
+#else
+#include <time.h>
+#include "udf_167.h"
+#include "udf_udf.h"
+#endif
+
+
+/* Since UDF 1.50 is ISO 13346 based... */
+#define UDF_SUPER_MAGIC	0x15013346
+
+/* Default block size - bigger is better */
+#define UDF_BLOCK_SIZE	2048
+
+#define UDF_NAME_PAD 4
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define htofss(x) \
+	((Uint16)((((Uint16)(x) & 0x00FFU) << 8) | \
+		  (((Uint16)(x) & 0xFF00U) >> 8)))
+ 
+#define htofsl(x) \
+	((Uint32)((((Uint32)(x) & 0x000000FFU) << 24) | \
+		  (((Uint32)(x) & 0x0000FF00U) <<  8) | \
+		  (((Uint32)(x) & 0x00FF0000U) >>  8) | \
+		  (((Uint32)(x) & 0xFF000000U) >> 24)))
+
+#define htofsll(x) \
+	((Uint64)((((Uint64)(x) & 0x00000000000000FFU) << 56) | \
+		  (((Uint64)(x) & 0x000000000000FF00U) << 40) | \
+		  (((Uint64)(x) & 0x0000000000FF0000U) << 24) | \
+		  (((Uint64)(x) & 0x00000000FF000000U) <<  8) | \
+		  (((Uint64)(x) & 0x000000FF00000000U) >>  8) | \
+		  (((Uint64)(x) & 0x0000FF0000000000U) >> 24) | \
+		  (((Uint64)(x) & 0x00FF000000000000U) >> 40) | \
+		  (((Uint64)(x) & 0xFF00000000000000U) >> 56)))		
+
+#define fstohs(x) (htofss(x))
+#define fstohl(x) (htofsl(x))
+#define fstohll(x) (htofsll(x))
+#else /* __BYTE_ORDER == __LITTLE_ENDIAN */
+#define htofss(x) (x)
+#define htofsl(x) (x)
+#define htofsll(x) (x)
+#define fstohs(x) (x)
+#define fstohl(x) (x)
+#define fstohll(x) (x)
+#endif
+
+/* structures */
+struct udf_directory_record {
+	Uint32	d_parent;
+	Uint32	d_inode;
+	Uint32	d_name[255];
+};
+
+struct ktm 
+{
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_isdst;
+};
+
+struct ustr {
+	Uint8 u_cmpID;
+	dstring u_name[UDF_NAME_LEN];
+	Uint8 u_len;
+	Uint8 padding;
+	unsigned long u_hash;
+};
+
+/* Miscellaneous UDF Prototypes */
+extern Uint16 udf_crc(Uint8 *, Uint32);
+extern int udf_build_ustr(struct ustr *, dstring *ptr, int size);
+extern int udf_build_ustr_exact(struct ustr *, dstring *ptr, int size);
+extern int udf_CS0toUTF8(struct ustr *, struct ustr *);
+extern int udf_UTF8toCS0(dstring *, struct ustr *, int);
+extern time_t *udf_stamp_to_time(time_t *, void *);
+extern time_t udf_converttime (struct ktm *);
+extern uid_t  udf_convert_uid(int);
+extern gid_t  udf_convert_gid(int);
+
+/* --------------------------
+ * debug stuff
+ * -------------------------- */
+/* Debugging levels */
+#define UDF_DEBUG_NONE	0
+#define UDF_DEBUG_LVL1	1
+#define UDF_DEBUG_LVL2	2
+#define UDF_DEBUG_LVL3	3
+#define UDF_DEBUG_CRUMB	4
+#define UDF_DEBUG_LVL5	5
+#define UDF_DEBUG_COOKIE	6
+#define UDF_DEBUG_LVL7	7
+#define UDF_DEBUG_LVL8	8
+#define UDF_DEBUG_LVL9	9
+#define UDF_DEBUG_DUMP	10
+
+/* module parms */
+extern int udf_debuglvl;
+extern int udf_strict;
+extern int udf_undelete;
+extern int udf_unhide;
+
+extern void udf_dump(char * buffer, int size);
+extern int udf_read_tagged_data(char *, int size, int fd, int block, int offset);
+extern Uint32 udf64_low32(Uint64);
+extern Uint32 udf64_high32(Uint64);
+/*
+extern struct FileIdentDesc * udf_get_fileident(void * buffer, 
+			int bufsize, int * offset, int * remainder);
+*/
+extern extent_ad * udf_get_fileextent(void * buffer, int bufsize, int * offset);
+extern long_ad * udf_get_filelongad(void * buffer, int bufsize, int * offset);
+extern short_ad * udf_get_fileshortad(void * buffer, int bufsize, int * offset);
+
+#define DUMP(X,S)	do { if (udf_debuglvl >= UDF_DEBUG_DUMP) udf_dump((X),(S)); } while(0)
+
+/* ---------------------------
+ * Kernel module definitions
+ * --------------------------- */
+#if defined(__linux__) && defined(__KERNEL__)
+#include <linux/fs.h>
+#include "udf_fs_sb.h"
+#include "udf_fs_i.h"
+
+
+/* Prototype for fs/filesystem.c */
+extern int init_udf_fs(void);
+extern struct inode_operations udf_inode_operations;
+
+extern void udf_debug_dump(struct buffer_head *);
+extern struct buffer_head *udf_read_tagged(struct super_block *, Uint32, Uint32);
+extern struct buffer_head *udf_read_untagged(struct super_block *, Uint32, Uint32);
+extern void udf_release_data(struct buffer_head *);
+extern long udf_block_from_inode(struct super_block *, long);
+extern long udf_inode_from_block(struct super_block *, long);
+
+#define DPRINTK(X,Y)	do { if (udf_debuglvl >= X) printk Y ; } while(0)
+#define PRINTK(X)	do { if (udf_debuglvl >= UDF_DEBUG_LVL1) printk X ; } while(0)
+
+#define CRUMB		DPRINTK(UDF_DEBUG_CRUMB, ("udf: file \"%s\" line %d\n", __FILE__, __LINE__))
+#define COOKIE(X)	DPRINTK(UDF_DEBUG_COOKIE, X)
+
+#else /* either not __linux__ or not __KERNEL__ */
+
+#define DPRINTK(X,Y)	
+#define PRINTK(X)	
+
+#define CRUMB		
+#define COOKIE(X)	
+
+#endif /* defined(__linux__) && defined(__KERNEL__) */
+
+
+
+#endif /* !defined(_LINUX_UDF_FS_H) */
diff -u --recursive --new-file v2.1.129/linux/include/linux/udf_fs_i.h linux/include/linux/udf_fs_i.h
--- v2.1.129/linux/include/linux/udf_fs_i.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/udf_fs_i.h	Sun Nov 29 16:54:24 1998
@@ -0,0 +1,51 @@
+#if !defined(_LINUX_UDF_FS_I_H)
+#define _LINUX_UDF_FS_I_H
+/*
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/udf_fs.h>
+
+struct udf_inode_info {
+	/* Physical address of inode */
+	Uint32 i_alloc_type;
+		/* next 3 are shortcuts to first extent */
+	Uint32 i_ext0Location;	/* partition relative */
+	Uint32 i_ext0Length;  	/* in blocks */
+	Uint32 i_ext0Offset;	/* for short directories */
+	Uint32 i_fileLengthHigh;
+	Uint32 i_fileLengthLow;
+	Uint32 i_dir_position;
+};
+
+#ifdef CONFIG_UDF_FS
+#define UDF_I(X)	(&((X)->u.udf_i))
+#else
+/* we're not compiled in, so we can't expect our stuff in <linux/fs.h> */
+#define UDF_I(X)	( (struct udf_inode_info *) &((X)->u.pipe_i))
+	/* god, this is slimy. stealing another filesystem's union area. */
+	/* for the record, pipe_i is 9 ints long, we're using 4  	 */
+#endif
+
+#define UDF_I_ALLOCTYPE(X)	(UDF_I(X)->i_alloc_type)
+#define UDF_I_EXT0LOC(X)	(UDF_I(X)->i_ext0Location)
+#define UDF_I_EXT0LEN(X)	(UDF_I(X)->i_ext0Length)
+#define UDF_I_EXT0OFFS(X)	(UDF_I(X)->i_ext0Offset)
+#define UDF_I_FILELENHIGH(X)	(UDF_I(X)->i_fileLengthHigh)
+#define UDF_I_FILELENLOW(X)	(UDF_I(X)->i_fileLengthLow)
+#define UDF_I_DIRPOS(X)		(UDF_I(X)->i_dir_position)
+
+#endif /* defined(__KERNEL__) */
+
+#endif /* !defined(_LINUX_UDF_FS_I_H) */
diff -u --recursive --new-file v2.1.129/linux/include/linux/udf_fs_sb.h linux/include/linux/udf_fs_sb.h
--- v2.1.129/linux/include/linux/udf_fs_sb.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/udf_fs_sb.h	Sun Nov 29 16:54:24 1998
@@ -0,0 +1,104 @@
+#if !defined(_LINUX_UDF_FS_SB_H)
+#define _LINUX_UDF_FS_SB_H
+/*
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ */
+#ifdef __KERNEL__
+
+#include <linux/time.h>
+
+
+struct udf_sb_info {
+	/* Default permissions */
+	mode_t s_mode;
+	gid_t s_gid;
+	uid_t s_uid;
+
+	/* Overall info */
+	Uint16 s_maxVolSeqNum;
+	Uint16 s_partitions;
+	Uint16 s_thispartition;
+	Uint16 s_thisvolume;
+
+	/* Volume ID */
+	Uint32 s_id_block;
+	Uint16 s_id_crc;
+
+	/* Block headers */
+	Uint32 s_session;
+	Uint32 s_anchor;
+	Uint32 s_lastblock;
+	Uint32 s_voldesc;
+	Uint32 s_fileset;
+	Uint32 s_rootdir;
+	Uint32 s_partition_root;
+	Uint32 s_partition_len;
+	Uint32 s_filecount;
+	Uint8  s_volident[32];
+
+	/* directory info */
+	Uint32 s_lastdirino;
+	Uint32 s_lastdirnum;
+
+	/* Root Info */
+	time_t s_recordtime;
+	timestamp s_timestamp;
+
+	/* Miscellaneous flags */
+	int s_flags;
+
+	/* Debugging level */
+	int s_debug;
+};
+
+#define UDF_FLAG_STRICT	0x00000001U
+#define UDF_FLAG_FIXED	0x00000004U
+
+#ifdef CONFIG_UDF_FS
+#define UDF_SB_ALLOC(X) 
+#define UDF_SB_FREE(X)  
+#define UDF_SB(X)	(&((X)->u.udf_sb))
+#else
+	/* else we kmalloc a page to hold our stuff */
+#define UDF_SB_ALLOC(X) \
+	((X)->u.generic_sbp=kmalloc(sizeof(struct udf_sb_info), GFP_KERNEL))
+#define UDF_SB_FREE(X)  { if ((X)->u.generic_sbp) { \
+				kfree( (X)->u.generic_sbp ); \
+				(X)->u.generic_sbp=NULL; \
+			  } }
+#define UDF_SB(X)	((struct udf_sb_info *) ((X)->u.generic_sbp))
+#endif
+
+#define IS_STRICT(X)	( UDF_SB(X)->s_flags & UDF_FLAG_STRICT)
+#define IS_FIXED(X)	( UDF_SB(X)->s_flags & UDF_FLAG_DEBUG)
+
+#define UDF_SB_SESSION(X)	( UDF_SB(X)->s_session )
+#define UDF_SB_ANCHOR(X)	( UDF_SB(X)->s_anchor )
+#define UDF_SB_VOLUME(X)	( UDF_SB(X)->s_thisvolume )
+#define UDF_SB_PARTITION(X)	( UDF_SB(X)->s_thispartition )
+#define UDF_SB_LASTBLOCK(X)	( UDF_SB(X)->s_lastblock )
+#define UDF_SB_VOLDESC(X)	( UDF_SB(X)->s_voldesc )
+#define UDF_SB_FILESET(X)	( UDF_SB(X)->s_fileset )
+#define UDF_SB_ROOTDIR(X)	( UDF_SB(X)->s_rootdir )
+#define UDF_SB_RECORDTIME(X)	( UDF_SB(X)->s_recordtime )
+#define UDF_SB_TIMESTAMP(X)	( UDF_SB(X)->s_timestamp )
+#define UDF_SB_PARTROOT(X)	( UDF_SB(X)->s_partition_root )
+#define UDF_SB_PARTLEN(X)	( UDF_SB(X)->s_partition_len )
+#define UDF_SB_FILECOUNT(X)	( UDF_SB(X)->s_filecount )
+#define UDF_SB_VOLIDENT(X)	( UDF_SB(X)->s_volident )
+#define UDF_SB_LASTDIRINO(X)	( UDF_SB(X)->s_lastdirino )
+#define UDF_SB_LASTDIRNUM(X)	( UDF_SB(X)->s_lastdirnum )
+
+#define UDF_BLOCK_OFFSET(X)	  ( UDF_SB_PARTROOT(X) )
+
+#endif	/* defined(__KERNEL__) */
+#endif /* !defined(_LINUX_UDF_FS_SB_H) */
diff -u --recursive --new-file v2.1.129/linux/include/linux/udf_udf.h linux/include/linux/udf_udf.h
--- v2.1.129/linux/include/linux/udf_udf.h	Wed Dec 31 19:00:00 1969
+++ linux/include/linux/udf_udf.h	Sun Nov 29 14:45:29 1998
@@ -0,0 +1,132 @@
+#if !defined(_LINUX_UDF_UDF_H)
+#define _LINUX_UDF_UDF_H
+/*
+ * udf_udf.h
+ *
+ * PURPOSE
+ *	OSTA-UDF(tm) format specification [based on ECMA 167 standard].
+ *	http://www.osta.org/
+ *
+ * CONTACTS
+ *	E-mail regarding any portion of the Linux UDF file system should be
+ *	directed to the development team mailing list (run by majordomo):
+ *		linux_udf@hootie.lvld.hp.com
+ *
+ * COPYRIGHT
+ *	This file is distributed under the terms of the GNU General Public
+ *	License (GPL). Copies of the GPL can be obtained from:
+ *		ftp://prep.ai.mit.edu/pub/gnu/GPL
+ *	Each contributing author retains all rights to their own work.
+ *
+ * HISTORY
+ *	July 1, 1997 - Andrew E. Mileski
+ *	Written, tested, and released.
+ *
+ * 10/2/98 dgb	changed UDF_ID_DEVELOPER
+ * 11/26/98 bf  changed UDF_ID_DEVELOPER, 
+ */
+
+/* -------- Basic types and constants ----------- */
+
+/* UDF character set (UDF 1.50 2.1.2) */
+#define UDF_CHAR_SET_TYPE	0
+#define UDF_CHAR_SET_INFO	"OSTA Compressed Unicode"
+
+#define UDF_ID_DEVELOPER	"*Linux UDFFS"
+ 
+#if 0
+struct LogicalVolIntegrityDescImpUse
+{
+	regid		impIdent;
+	Uint32		numFiles;
+	Uint32		numDirs;
+	Uint16		minUDFReadRev;
+	Uint16		minUDFWriteRev;
+	Uint16		maxUDFWriteRev;
+};
+
+struct ImpUseVolDescImpUse
+{
+	charspec	LVICharset;
+	dstring		logicalVolIdent[128];
+	dstring		LVInfo1[36];
+	dstring		LVInfo2[36];
+	dstring		LVInfo3[36];
+	regid		impIdent;
+	Uint8		impUse[128];
+};
+
+struct VirtualPartitionMap
+{
+	Uint8		partitionMapType;	/* 2 */
+	Uint8		partitionMapLength;	/* 64 */
+	Uint8		reserved1[2];		/* #00 */
+	regid		partIdent;
+	Uint16		volSeqNum;
+	Uint16		partitionNum;
+	Uint8		reserved2[24];		/* #00 */
+};
+
+struct SparablePartitionMap
+{
+	Uint8		partitionMapType;	/* 2 */
+	Uint8		partitionMapLength;	/* 64 */
+	Uint8		reserved1[2];		/* #00 */
+	regid		partIdent;		/* Flags = 0 */
+						/* Id = UDF_ID_SPARABLE */
+						/* IdSuf = 2.1.5.3 */
+	Uint16		volSeqNum;
+	Uint16		partitioNum;
+	Uint16		packetLength;		/* 32 */
+	Uint8		numSparingTables;
+	Uint8		reserved2[1];		/* #00 */
+	Uint32		sizeSparingTable;
+	Uint32		locSparingTable[0];
+	Uint8		pad[0];
+};
+#endif
+ 
+/* Entity Identifiers (UDF 1.50 6.1) */
+#define	UDF_ID_COMPLIANT	"*OSTA UDF Compliant"
+#define UDF_ID_LV_INFO		"*UDF LV Info"
+#define UDF_ID_FREE_EA		"*UDF FreeEASpace"
+#define UDF_ID_FREE_APP_EA	"*UDF FreeAppEASpace"
+#define UDF_ID_DVD_CGMS		"*UDF DVD CGMS Info"
+#define UDF_ID_OS2_EA		"*UDF OS/2 EA"
+#define UDF_ID_OS2_EA_LENGTH	"*UDF OS/2 EALength"
+#define UDF_ID_MAC_VOLUME	"*UDF Mac VolumeInfo"
+#define UDF_ID_MAC_FINDER	"*UDF Mac FinderInfo"
+#define UDF_ID_MAC_UNIQUE	"*UDF Mac UniqueIDTable"
+#define UDF_ID_MAC_RESOURCE	"*UDF Mac ResourceFork"
+#define UDF_ID_PARTITION	"*UDF Virtual Partition"
+#define UDF_ID_SPARABLE		"*UDF Sparable Partition"
+#define UDF_ID_ALLOC		"*UDF Virtual Alloc Tbl"
+#define UDF_ID_SPARING		"*UDF Sparing Table"
+
+/* Operating System Identifiers (UDF 1.50 6.3) */
+#define UDF_OS_CLASS_UNDEF	0x00U
+#define UDF_OS_CLASS_DOS	0x01U
+#define UDF_OS_CLASS_OS2	0x02U
+#define UDF_OS_CLASS_MAC	0x03U
+#define UDF_OS_CLASS_UNIX	0x04U
+#define UDF_OS_CLASS_WIN95	0x05U
+#define UDF_OS_CLASS_WINNT	0x06U
+#define UDF_OS_ID_UNDEF		0x00U
+#define UDF_OS_ID_DOS		0x00U
+#define UDF_OS_ID_OS2		0x00U
+#define UDF_OS_ID_MAC		0x00U
+#define UDF_OS_ID_UNIX		0x00U
+#define UDF_OS_ID_WIN95		0x00U
+#define UDF_OS_ID_WINNT		0x00U
+#define UDF_OS_ID_AIX		0x01U
+#define UDF_OS_ID_SOLARIS	0x02U
+#define UDF_OS_ID_HPUX		0x03U
+#define UDF_OS_ID_IRIX		0x04U
+#define UDF_OS_ID_LINUX		0x05U
+#define UDF_OS_ID_MKLINUX	0x06U
+#define UDF_OS_ID_FREEBSD	0x07U
+
+#define UDF_NAME_LEN	253
+#define UDF_PATH_LEN	1023
+
+#endif /* !defined(_LINUX_UDF_FMT_H) */
diff -u --recursive --new-file v2.1.129/linux/Documentation/filesystems/udf.txt linux/Documentation/filesystems/udf.txt
--- v2.1.129/linux/Documentation/filesystems/udf.txt	Wed Dec 31 19:00:00 1969
+++ linux/Documentation/filesystems/udf.txt	Sun Nov 29 17:11:36 1998
@@ -0,0 +1,48 @@
+UDF Filesystem version 0.7
+
+If you encounter problems with reading UDF discs using this driver,
+please report them to linux_udf@hootie.lvld.hp.com, which is the
+developer's list.
+
+The driver is known to work 'ok' for discs written with Adaptec's
+DirectCD 2.5, although there's a problem with mis-reported file
+sizes, effecting 'du' and 'ls -ls'.
+
+The 'find' command doesn't like some directories. YMMV.
+
+The 'diff' command works ok on individual files, but complains
+about file errors when run recursively. 
+
+
+ * ---------------------------------------------------------------------
+ *	The following mount options are supported:
+ *
+ *	fixed		Disable removable media checks.
+ *	gid=		Set the default group.
+ *	mode=		Set the default mode.
+ *	uid=		Set the default user.
+ *      unhide
+ *      undelete
+ *
+ *	The following are for debugging and disaster recovery:
+ *
+ *	bs=		Set the block size. (may not work unless 2048)
+ *	debug=		Set the debugging level for _all_ UDF filesystems.
+ *      novrs           Skip volume sequence recognition (my RW cd recorded by 
+ *          ADAPTEC DirectCD 2.5 has no such sequence but otherwise is fine
+ *	strict		Set strick conformance.
+ *
+ *	The following expect a parameter given in 'sectors':
+ *
+ *	session=	Set the CDROM session (default= last session)
+ *	anchor=		Override standard anchor location. (default= 256)
+ *	volume=		Override the VolumeDesc location.
+ *	partition=	Override the PartitionDesc location.
+ *	partroot=	Override the partitionStartingLocation.
+ *
+ *	The following expect a parameter given in 'blocks', 
+ *		which are added to the partition root to get a 'sector':
+ *
+ *	fileset=	Override the fileset block location.
+ *	rootdir=	Override the root directory location.
+ *
